<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ΝΗΡΕΑΣ — Πρωτότυπο (GitHub Pages)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #111827;
      --panel2: #0f172a;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --ok: #34d399;
      --warn: #fbbf24;
      --bad: #fb7185;
      --border: rgba(255,255,255,.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
    }
    header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
    }
    header .title { font-weight: 700; letter-spacing: .2px; }
    header .subtitle { color: var(--muted); font-size: 13px; margin-top: 2px; }
    .wrap {
      display: grid;
      grid-template-columns: 420px 1fr;
      height: calc(100vh - 66px);
    }
    @media (max-width: 980px) {
      .wrap { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
      #map { height: 55vh; }
    }
    .panel {
      padding: 14px 16px;
      border-right: 1px solid var(--border);
      background: var(--panel2);
      overflow: auto;
    }
    .card {
      background: rgba(255,255,255,.03);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
    }
    label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    select, button {
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline: none;
    }
    button { cursor: pointer; background: rgba(255,255,255,.06); }
    button:hover { background: rgba(255,255,255,.10); }
    .row { display:flex; gap: 10px; }
    .row > * { flex: 1; }
    .kpis {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .kpi {
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.2);
    }
    .kpi .v { font-size: 18px; font-weight: 800; }
    .kpi .l { font-size: 12px; color: var(--muted); margin-top: 2px; }
    .status {
      display:flex; align-items:center; justify-content:space-between;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.18);
      font-size: 13px;
      margin-top: 8px;
    }
    .pill {
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
    }
    .pill.ok { color: var(--ok); border-color: rgba(52,211,153,.35); }
    .pill.bad { color: var(--bad); border-color: rgba(251,113,133,.35); }
    .pill.warn { color: var(--warn); border-color: rgba(251,191,36,.35); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #map { height: 100%; }
    .small { font-size: 12px; color: var(--muted); line-height: 1.35; }
    a { color: #93c5fd; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>

<body>
<header>
  <div class="title">ΝΗΡΕΑΣ — Πρωτότυπο (online & τοπικά)</div>
  <div class="subtitle">Διαβάζει τα αρχεία από το repo (GeoJSON + stations.txt) και φέρνει βροχή μέσω Open‑Meteo. (Generated: 2025-12-27 14:22 UTC)</div>
</header>

<div class="wrap">
  <div class="panel">
    <div class="card">
      <div class="row">
        <div>
          <label for="stationSelect">Μετεωρολογικός “σταθμός”</label>
          <select id="stationSelect"></select>
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="btnRefresh">Ανανέωση</button>
        </div>
      </div>

      <div class="kpis">
        <div class="kpi">
          <div class="v" id="kpi1h">—</div>
          <div class="l">Τελευταία 1 ώρα (mm)</div>
        </div>
        <div class="kpi">
          <div class="v" id="kpi3h">—</div>
          <div class="l">Σύνολο 3 ωρών (mm)</div>
        </div>
        <div class="kpi">
          <div class="v" id="kpi24h">—</div>
          <div class="l">Σύνολο 24 ωρών (mm)</div>
        </div>
        <div class="kpi">
          <div class="v" id="kpiTs">—</div>
          <div class="l">Τελευταία ενημέρωση</div>
        </div>
      </div>

      <div class="status">
        <div>Boundary (GeoJSON)</div>
        <div class="pill" id="stBoundary">…</div>
      </div>
      <div class="status">
        <div>Stations list (stations.txt)</div>
        <div class="pill" id="stStations">…</div>
      </div>
      <div class="status">
        <div>Open‑Meteo API</div>
        <div class="pill" id="stApi">…</div>
      </div>
    </div>

    <div class="card">
      <div style="font-weight:700;margin-bottom:6px;">Διαγνωστικά</div>
      <div class="small">
        Αν <b>δεν</b> βλέπεις δεδομένα στο GitHub Pages, το 99% είναι ότι ο browser μπλοκάρει ανάγνωση από <span class="mono">penteli.meteo.gr</span> (CORS).
        Αυτό το prototype χρησιμοποιεί <b>Open‑Meteo</b> για να δουλεύει online χωρίς proxy.
      </div>
      <div class="small" style="margin-top:10px;">
        Αρχεία που διαβάζει:
        <ul>
          <li class="mono">./data/boundaries/geojson/municipal_chalandriou.geojson</li>
          <li class="mono">./data/meteostations/weblinks/stations.txt</li>
          <li class="mono">./data/meteostations/API/openmeteo.txt (προαιρετικό)</li>
        </ul>
      </div>
      <div class="small">
        Τρέχει τοπικά: <span class="mono">python -m http.server</span> και άνοιξε <span class="mono">http://localhost:8000/</span>.
      </div>
    </div>
  </div>

  <div id="map"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
(() => {
  const PATHS = {
    boundary: './data/boundaries/geojson/municipal_chalandriou.geojson',
    stations: './data/meteostations/weblinks/stations.txt',
    coords: './data/meteostations/API/stations_coords.json'
  };

  // Built-in coordinates (override by creating stations_coords.json)
  const BUILTIN_COORDS = {"chalandri": [38.021332, 23.79863, "Χαλάνδρι"], "nomismatokopeio": [38.00917, 23.80583, "Νομισματοκοπείο"], "vrilissia": [38.0338111111, 23.8296194444, "Βριλήσσια"], "agia-paraskevi": [38.0167, 23.8333, "Αγία Παρασκευή"], "papagou": [37.9864194444, 23.7934694444, "Παπάγου"], "psychico": [38.0132388889, 23.7722305556, "Ψυχικό"], "gerakas": [38.011751, 23.854839, "Γέρακας"], "kifissia": [38.075989, 23.815899, "Κηφισιά"], "penteli-top": [38.047492, 23.865362, "Πεντέλη"]};

  const $ = (id) => document.getElementById(id);
  const stBoundary = $('stBoundary');
  const stStations = $('stStations');
  const stApi = $('stApi');

  const stationSelect = $('stationSelect');
  const btnRefresh = $('btnRefresh');

  const kpi1h = $('kpi1h');
  const kpi3h = $('kpi3h');
  const kpi24h = $('kpi24h');
  const kpiTs = $('kpiTs');

  function setPill(el, kind, text) {
    el.className = 'pill ' + (kind || '');
    el.textContent = text;
  }

  function fmtNum(x) {
    if (x === null || x === undefined || Number.isNaN(x)) return '—';
    return (Math.round(x * 10) / 10).toFixed(1);
  }

  async function fetchText(url) {
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    return await res.text();
  }

  async function fetchJson(url) {
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    return await res.json();
  }

  function parseStationIdFromUrl(u) {
    try {
      const m = String(u).match(/\/stations\/([^\/]+)\//i);
      return m ? m[1].trim() : null;
    } catch (e) {
      return null;
    }
  }

  function titleFromId(id) {
    return id
      .replace(/[-_]+/g, ' ')
      .replace(/\w/g, c => c.toUpperCase());
  }

  function parseStationsText(text) {
    // Accept:
    // - whitespace-separated URLs
    // - one URL per line
    // - pipe-delimited lines: id|name|lat|lon|url
    const lines = String(text).split(/
?
/).map(l => l.trim()).filter(Boolean).filter(l => !l.startsWith('#'));
    let stations = [];

    // If file is one long line with many URLs, split by whitespace
    const rawItems = (lines.length === 1 && lines[0].includes('http')) ? lines[0].split(/\s+/) : lines;

    for (const item of rawItems) {
      if (!item) continue;

      if (item.includes('|')) {
        const parts = item.split('|').map(x => x.trim());
        const id = parts[0];
        const name = parts[1] || null;
        const lat = parts[2] ? Number(parts[2]) : null;
        const lon = parts[3] ? Number(parts[3]) : null;
        const url = parts[4] || null;
        stations.push({ id, name, lat, lon, url });
        continue;
      }

      if (item.startsWith('http')) {
        const url = item;
        const id = parseStationIdFromUrl(url) || ('weblink_' + Math.random().toString(36).slice(2,8));
        stations.push({ id, name: null, lat: null, lon: null, url });
      }
    }

    // Deduplicate by id
    const seen = new Set();
    stations = stations.filter(s => {
      if (!s.id || seen.has(s.id)) return false;
      seen.add(s.id);
      return true;
    });

    return stations;
  }

  function applyCoords(stations, coordsMap) {
    return stations.map(s => {
      const c = coordsMap[s.id] || BUILTIN_COORDS[s.id];
      if (c && (!isFinite(s.lat) || !isFinite(s.lon))) {
        s.lat = Number(c[0]);
        s.lon = Number(c[1]);
      }
      if (c && (!s.name || !String(s.name).trim())) {
        s.name = c[2] || s.name;
      }
      if (!s.name) s.name = titleFromId(s.id);
      return s;
    });
  }

  function openMeteoUrl(lat, lon) {
    const params = new URLSearchParams({
      latitude: String(lat),
      longitude: String(lon),
      hourly: 'precipitation',
      timezone: 'Europe/Athens',
      past_days: '2',
      forecast_days: '1'
    });
    return `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
  }

  function computeSums(times, prec) {
    const n = Math.min(times.length, prec.length);
    const now = new Date();
    let lastIdx = -1;
    for (let i = 0; i < n; i++) {
      const t = new Date(times[i]);
      if (t <= now) lastIdx = i;
      else break;
    }
    if (lastIdx < 0) lastIdx = n - 1;

    const get = (i) => (i>=0 && i<n) ? (Number(prec[i]) || 0) : 0;

    const last1h = get(lastIdx);
    let sum3 = 0;
    for (let k = 0; k < 3; k++) sum3 += get(lastIdx - k);

    let sum24 = 0;
    for (let k = 0; k < 24; k++) sum24 += get(lastIdx - k);

    const ts = times[lastIdx] || null;
    return { last1h, sum3, sum24, ts };
  }

  // Map
  const map = L.map('map', { zoomControl: true });
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  let boundaryLayer = null;
  let stationsLayer = L.layerGroup().addTo(map);
  let selectedMarker = null;

  function setViewDefault() {
    map.setView([38.02, 23.81], 12);
  }
  setViewDefault();

  async function loadBoundary() {
    try {
      const gj = await fetchJson(PATHS.boundary);
      if (boundaryLayer) boundaryLayer.remove();
      boundaryLayer = L.geoJSON(gj, { style: { weight: 2, opacity: 0.9, fillOpacity: 0.08 } }).addTo(map);
      try { map.fitBounds(boundaryLayer.getBounds(), { padding: [20,20] }); } catch (e) {}
      setPill(stBoundary, 'ok', 'OK');
    } catch (e) {
      console.warn('Boundary load failed:', e);
      setPill(stBoundary, 'warn', 'Δεν φορτώθηκε');
    }
  }

  async function loadCoordsMap() {
    try {
      const obj = await fetchJson(PATHS.coords);
      return obj || {};
    } catch (e) {
      return {};
    }
  }

  async function loadStations() {
    const txt = await fetchText(PATHS.stations);
    let stations = parseStationsText(txt);

    const coords = await loadCoordsMap();
    stations = applyCoords(stations, coords);

    const usable = stations.filter(s => isFinite(s.lat) && isFinite(s.lon));
    const unusable = stations.filter(s => !isFinite(s.lat) || !isFinite(s.lon));

    setPill(stStations, usable.length ? 'ok' : 'bad', usable.length ? `${usable.length} usable` : '0 usable');
    if (unusable.length) console.warn('Stations without coords (ignored):', unusable.map(s => s.id));

    stationSelect.innerHTML = '';
    for (const s of usable) {
      const opt = document.createElement('option');
      opt.value = s.id;
      opt.textContent = s.name;
      stationSelect.appendChild(opt);
    }

    stationsLayer.clearLayers();
    for (const s of usable) {
      const m = L.marker([s.lat, s.lon]).addTo(stationsLayer);
      m.bindPopup(`<b>${escapeHtml(s.name)}</b><br/><span class="mono">${escapeHtml(s.id)}</span>`);
      m.on('click', () => { stationSelect.value = s.id; refreshSelected().catch(console.error); });
      s._marker = m;
    }

    if (usable.length) stationSelect.value = usable[0].id;
    return usable;
  }

  function escapeHtml(s) {
    return String(s ?? '').replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  const dataCache = new Map(); // id -> { tsFetched, sums }

  async function fetchOpenMeteoForStation(station) {
    const key = station.id;
    const cached = dataCache.get(key);
    const now = Date.now();
    if (cached && (now - cached.tsFetched) < 60_000) return cached.sums;

    const url = openMeteoUrl(station.lat, station.lon);
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`Open-Meteo HTTP ${res.status}`);
    const json = await res.json();

    const times = json?.hourly?.time || [];
    const prec = json?.hourly?.precipitation || [];
    const sums = computeSums(times, prec);

    dataCache.set(key, { tsFetched: now, sums });
    return sums;
  }

  function setSelectedMarker(station) {
    if (selectedMarker) { selectedMarker.setOpacity(1); selectedMarker = null; }
    if (station && station._marker) {
      selectedMarker = station._marker;
      selectedMarker.openPopup();
      try { map.panTo([station.lat, station.lon]); } catch(e) {}
    }
  }

  let stations = [];

  async function refreshSelected() {
    const id = stationSelect.value;
    const st = stations.find(s => s.id === id);
    if (!st) return;

    try {
      setPill(stApi, '', '…');
      const sums = await fetchOpenMeteoForStation(st);
      setPill(stApi, 'ok', 'OK');

      kpi1h.textContent = fmtNum(sums.last1h);
      kpi3h.textContent = fmtNum(sums.sum3);
      kpi24h.textContent = fmtNum(sums.sum24);
      kpiTs.textContent = sums.ts ? new Date(sums.ts).toLocaleString('el-GR') : new Date().toLocaleString('el-GR');

      setSelectedMarker(st);
    } catch (e) {
      console.warn('Open-Meteo error:', e);
      setPill(stApi, 'bad', 'Σφάλμα');
      kpi1h.textContent = '—';
      kpi3h.textContent = '—';
      kpi24h.textContent = '—';
      kpiTs.textContent = new Date().toLocaleString('el-GR');
    }
  }

  btnRefresh.addEventListener('click', () => refreshSelected().catch(console.error));
  stationSelect.addEventListener('change', () => refreshSelected().catch(console.error));

  (async () => {
    setPill(stBoundary, '', '…');
    setPill(stStations, '', '…');
    setPill(stApi, '', '…');

    await loadBoundary();
    stations = await loadStations();
    if (stations.length) await refreshSelected();
    else setPill(stApi, 'warn', 'Χωρίς σταθμούς');
  })();

})();
</script>

</body>
</html>
