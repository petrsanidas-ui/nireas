<script>
  // --- CONFIG ---
  const GH_USER = 'petrsanidas-ui';
  const GH_REPO = 'nireas';
  const GH_BRANCH = 'main';
  const API_TREE = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/git/trees/${GH_BRANCH}?recursive=1`;
  const RAW_URL = `https://raw.githubusercontent.com/${GH_USER}/${GH_REPO}/${GH_BRANCH}/`;

  let BASINS = [];
  let SELECTED_BASIN_GEO = null;
  let map, lyr;

  // --- INIT ---
  async function init() {
    document.getElementById('loader').style.display = 'block';
    
    try {
       // 1. Λήψη λίστας αρχείων από GitHub
       const resp = await fetch(API_TREE);
       const data = await resp.json();
       if(data.message) throw new Error(data.message);
       
       const files = data.tree;

       // 2. Εύρεση Λεκανών (.geojson)
       BASINS = files.filter(f => f.path.includes('data/basins/') && f.path.endsWith('.geojson'));
       renderBasinList();

       // 3. Εύρεση Σταθμών (Δυναμική σάρωση)
       // Α. Αρχεία μέσα στο φάκελο api (π.χ. ecmwf.txt, openmeteo.txt)
       const apiFiles = files.filter(f => f.path.includes('data/meteostations/api/') && f.path.endsWith('.txt'));
       
       // Β. Το γενικό αρχείο stations.txt (αν υπάρχει αλλού)
       const generalFile = files.find(f => f.path === 'stations.txt' || f.path.includes('data/stations.txt'));

       // Κλήση της νέας συνάρτησης που τα διαχειρίζεται όλα
       await fetchAllStations(apiFiles, generalFile);

    } catch(e) {
       console.error(e);
       updateMeteoStatus("Σφάλμα GitHub: " + e.message);
    } finally {
       document.getElementById('loader').style.display = 'none';
    }
  }

  // --- LOGIC ΓΙΑ ΣΤΑΘΜΟΥΣ (API FILES + GENERAL) ---
  async function fetchAllStations(apiFiles, generalFile) {
     const sel = document.getElementById('meteoStationSelect');
     sel.innerHTML = '<option value="">Επιλογή σταθμού...</option>';

     // 1. Δυναμική φόρτωση αρχείων API (π.χ. ECMWF, OPENMETEO)
     if(apiFiles.length > 0) {
         for (const file of apiFiles) {
             try {
                 // Παίρνουμε το όνομα από το αρχείο (π.χ. "ecmwf.txt" -> "ECMWF")
                 const groupName = file.path.split('/').pop().replace('.txt', '').toUpperCase();
                 
                 const resp = await fetch(RAW_URL + file.path);
                 const text = await resp.text();
                 
                 // Δημιουργία Group στο Select
                 const grp = document.createElement('optgroup'); 
                 grp.label = groupName; // Εδώ θα λέει ECMWF, OPENMETEO κλπ.
                 
                 text.split('\n').forEach(line => {
                     const opt = createOptionFromLine(line, groupName); // Περνάμε το groupName για να ξέρουμε την πηγή
                     if(opt) grp.appendChild(opt);
                 });
                 sel.appendChild(grp);
             } catch(err) { console.warn("Σφάλμα στο αρχείο " + file.path, err); }
         }
     }

     // 2. Φόρτωση Γενικών Web Links (stations.txt)
     if(generalFile) {
         try {
             const resp = await fetch(RAW_URL + generalFile.path);
             const text = await resp.text();
             
             const grpWeb = document.createElement('optgroup'); 
             grpWeb.label = "WEB LINKS (Meteo.gr κλπ)";
             
             text.split('\n').forEach(line => {
                 const opt = createOptionFromLine(line, "WEB");
                 if(opt) grpWeb.appendChild(opt);
             });
             sel.appendChild(grpWeb);
         } catch(err) { console.warn("Σφάλμα στο stations.txt", err); }
     }
  }

  // Βοηθητική: Μετατρέπει γραμμή κειμένου σε <option>
  function createOptionFromLine(line, source) {
      if(!line.trim()) return null;
      let name = "";
      let value = line.trim();

      // Μορφή "Όνομα | URL" ή "Όνομα | Coordinates"
      if(line.includes('|')) {
          const parts = line.split('|');
          name = parts[0].trim();
          value = parts[1].trim();
      } 
      // Σκέτο URL
      else if(value.startsWith('http')) {
          try { 
              const cleanUrl = value.endsWith('/') ? value.slice(0, -1) : value;
              name = cleanUrl.split('/').pop().toUpperCase(); 
          } catch(e){ name = "ΣΤΑΘΜΟΣ"; }
      }
      // Σκέτο Όνομα (π.χ. σε λίστα ECMWF)
      else {
          name = value; // Αν είναι σκέτο όνομα, το value είναι το όνομα
      }

      const opt = document.createElement('option');
      opt.value = value;
      opt.text = name;
      opt.dataset.source = source; // Κρατάμε την πηγή (π.χ. ECMWF) στα data
      return opt;
  }

  // --- ΥΠΟΛΟΙΠΕΣ ΛΕΙΤΟΥΡΓΙΕΣ (ΙΔΙΕΣ ΜΕ ΠΡΙΝ) ---

  function openStationWeb() {
      const sel = document.getElementById('meteoStationSelect');
      const val = sel.value;
      if(val && val.startsWith('http')) {
          window.open(val, '_blank');
      } else {
          alert("Η επιλογή δεν είναι Web Link. Χρησιμοποιήστε το κουμπί 'Λήψη API'.");
      }
  }

  async function fetchStationData() {
      const sel = document.getElementById('meteoStationSelect');
      const val = sel.value;
      const opt = sel.options[sel.selectedIndex];
      const source = opt ? opt.dataset.source : "";

      if(!val) { alert("Επιλέξτε σταθμό"); return; }
      
      updateMeteoStatus(`Σύνδεση με ${source}...`);

      // Λογική ανάλογα με την πηγή
      if(source === "ECMWF") {
          // Εδώ θα μπει η λογική για ECMWF
          mockFetch(val, source);
      } else if (source === "OPENMETEO") {
          // Εδώ θα μπει η λογική για OpenMeteo
          mockFetch(val, source);
      } else if (val.includes('meteo.gr')) {
          mockFetch(val, "Meteo.gr");
      } else {
          updateMeteoStatus("Άγνωστο API. Δοκιμάστε το Web Link.");
      }
  }

  function mockFetch(name, source) {
      setTimeout(() => {
          const mockRain = (Math.random() * 15).toFixed(1);
          document.getElementById('rainI').value = mockRain;
          updateMeteoStatus(`Επιτυχία! ${source} (${name}): ${mockRain} mm/h`);
          calc();
      }, 800);
  }

  async function fetchLiveMeteo() {
      let lat = 38.02, lon = 23.80; 
      if (SELECTED_BASIN_GEO) {
          try {
             const coords = SELECTED_BASIN_GEO.features[0].geometry.coordinates[0][0];
             lon = coords[0]; lat = coords[1];
          } catch(e) {}
      }
      updateMeteoStatus(`Open-Meteo (${lat.toFixed(2)},${lon.toFixed(2)})...`);
      try {
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=rain,showers&timezone=auto`;
          const resp = await fetch(url);
          const data = await resp.json();
          const rain = data.current.rain + data.current.showers;
          document.getElementById('rainI').value = rain.toFixed(1);
          updateMeteoStatus(`Open-Meteo GPS: ${rain} mm/h`);
          calc();
      } catch(e) { updateMeteoStatus("Σφάλμα API: " + e.message); }
  }

  function updateMeteoStatus(msg) { document.getElementById('meteoStatus').innerText = msg; }

  function renderBasinList() {
     const tbody = document.getElementById('basinRows');
     tbody.innerHTML = '';
     BASINS.forEach(b => {
        const name = b.path.split('/').pop().replace('.geojson','');
        const tr = document.createElement('tr');
        tr.innerHTML = `
           <td style="text-align:left; font-weight:bold;">${name}</td>
           <td><span id="badge_${name}" style="background:#eee; padding:2px 5px; border-radius:4px; font-size:9px;">-</span></td>
           <td>
             <button class="mini-btn btn-load" onclick="loadBasin('${b.path}', '${name}')">Load</button>
             <button class="mini-btn btn-map" onclick="showMap('${b.path}')">Map</button>
           </td>
        `;
        tbody.appendChild(tr);
     });
  }

  async function loadBasin(path, id) {
     updateMeteoStatus("Φόρτωση λεκάνης...");
     const resp = await fetch(RAW_URL + path);
     const json = await resp.json();
     SELECTED_BASIN_GEO = json; 
     const p = json.features && json.features[0] ? json.features[0].properties : {};
     if(p.area) document.getElementById('area').value = p.area;
     if(p.length) document.getElementById('length').value = p.length;
     if(p.height) document.getElementById('height').value = p.height;
     if(p.coef) document.getElementById('coef').value = p.coef;
     updateMeteoStatus(`Φορτώθηκε: ${id}`);
     calc();
  }

  function calc() {
     const I = parseFloat(document.getElementById('rainI').value)||0;
     const A = parseFloat(document.getElementById('area').value)||0;
     const L = parseFloat(document.getElementById('length').value)||0;
     const H = parseFloat(document.getElementById('height').value)||0;
     const C = parseFloat(document.getElementById('coef').value)||0;
     
     const Akm2 = A / 1e6;
     const Qpeak = 0.278 * C * I * Akm2;
     
     let Tc = 0;
     if(L > 0 && H > 0) {
        const S = H / L;
        Tc = 0.0195 * Math.pow(L, 0.77) * Math.pow(S, -0.385);
     }
     
     const b = parseFloat(document.getElementById('strWidth').value)||0;
     const h_depth = parseFloat(document.getElementById('strDepth').value)||0;
     const n = parseFloat(document.getElementById('strN').value)||0.03;
     let Qcap = 0;
     if(b>0 && h_depth>0 && L>0 && H>0) {
         const S_slp = H/L;
         const A_sec = b * h_depth;
         const P = b + 2*h_depth;
         const R = A_sec / P;
         Qcap = (1/n) * A_sec * Math.pow(R, 2/3) * Math.sqrt(S_slp);
     }

     document.getElementById('res-qsel').innerText = Qpeak.toFixed(2) + " m³/s";
     document.getElementById('res-cap').innerText = Qcap.toFixed(2) + " m³/s";
     document.getElementById('res-tc').innerText = Tc.toFixed(1) + " min";
     
     const stat = document.getElementById('res-status');
     if(Qpeak > 0 && Qcap > 0) {
         if(Qpeak < Qcap) { stat.innerHTML = "<span style='color:green'>OK</span>"; }
         else { stat.innerHTML = "<span style='color:red; font-weight:bold;'>ΚΙΝΔΥΝΟΣ</span>"; }
     } else {
         stat.innerText = "—";
     }
  }

  async function showMap(path) {
     const modal = document.getElementById('mapModal');
     modal.style.display = 'flex';
     if(!map) {
       map = L.map('mapBox').setView([38.02, 23.80], 13);
       L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
     } else { map.invalidateSize(); }
     if(lyr) lyr.remove();
     const resp = await fetch(RAW_URL + path);
     const json = await resp.json();
     lyr = L.geoJSON(json).addTo(map);
     map.fitBounds(lyr.getBounds());
  }
  
  function togglePanel() {
      const b = document.getElementById('basinPanelBody');
      b.style.display = b.style.display === 'none' ? 'block' : 'none';
  }

  window.onload = init;
</script>
