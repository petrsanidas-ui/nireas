<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NIREAS</title>

  
  <link rel="icon" type="image/png" href="nireas_logo.png" />
<!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --bg:#eef2f5;
      --panel:#ffffff;
      --ink:#2c3e50;
      --muted:#6b7a86;
      --line:#d6dde4;
      --hdr:#2c3e50;

      --btn-blue:#2980b9;
      --btn-green:#27ae60;
      --btn-gray:#7f8c8d;

      --danger:#c0392b;
      --warn:#d35400;
      --ok:#27ae60;

      --shadow:0 10px 24px rgba(0,0,0,.12);
      --radius:10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:var(--bg);
      color:var(--ink);
    }

    /* ====== Layout (side-by-side, no overlap) ====== */
    .app-shell{
      display:flex;
      gap:14px;
      padding:14px;
      align-items:flex-start;
    }
    @media (max-width: 1100px){
      .app-shell{flex-direction:column}
    }

    .side-panel{
      width:390px;
      max-width:100%;
      background:var(--panel);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      border:1px solid rgba(0,0,0,.06);
    }
    .main-panel{
      flex:1;
      min-width:380px;
      background:var(--panel);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      border:1px solid rgba(0,0,0,.06);
    }

    /* ====== Panel headers & collapsibles ====== */
    .panel-topbar{
      background:var(--hdr);
      color:#fff;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      font-weight:700;
      font-size:14px;
    }
    .icon-btn{
      border:none;
      background:rgba(255,255,255,.14);
      color:currentColor; /* inherits from parent (white on dark topbar, dark on light headers) */
      width:30px;height:26px;
      border-radius:6px;
      cursor:pointer;
      font-weight:900;
      line-height:1;
    }
    .icon-btn:hover{background:rgba(255,255,255,.22)} 

    /* Make collapse/minimize buttons visible on light section headers */
    .section-hdr .icon-btn{
      background:rgba(44,62,80,.10);
      border:1px solid rgba(0,0,0,.10);
    }
    .section-hdr .icon-btn:hover{background:rgba(44,62,80,.16)}
    .section{
      border-top:1px solid rgba(255,255,255,.08);
    }
    .section-hdr{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-top:1px solid var(--line);
      background:#f7f9fb;
      font-weight:800;
      color:var(--ink);
    }
    .section-body{
      padding:10px 12px;
    }
    .collapsed{display:none!important}

    /* ====== Buttons ====== */
    .mini-btn{
      border:none;
      border-radius:4px;
      padding:4px 8px;
      font-size:11px;
      cursor:pointer;
      color:#fff;
      font-weight:800;
      line-height:1.1;
      user-select:none;
    }
    .btn-load{background:var(--btn-blue)}
    .btn-map{background:var(--btn-green)}
    .btn-gray{background:var(--btn-gray)}
    .btn-on{background:var(--btn-green)}
    .btn-off{background:var(--btn-gray)}

    /* Station monitor button states */
    .btn-auto-default{background:var(--btn-blue)}
    .btn-auto-live{background:var(--btn-green)}
    .btn-live-off{background:var(--danger)}
    .btn-live-on{background:var(--btn-green)}
    .temp-green{background:var(--btn-green)!important}

/* Station time-series list */
.series-list{margin-top:6px;border:1px solid #dfe7ee;border-radius:10px;padding:6px;background:#fff;max-height:160px;overflow:auto;font-size:11px}
.series-row{display:flex;align-items:baseline;justify-content:space-between;gap:8px;padding:4px 0;border-bottom:1px dashed #e6eef5}
.series-row:last-child{border-bottom:none}
.series-ts{color:var(--muted);min-width:125px}
.series-val{font-weight:700;white-space:nowrap}
.series-dp{color:var(--muted);white-space:nowrap}

    .mini-btn:hover{filter:brightness(.95)}
    .mini-btn:active{transform:translateY(1px)}

    /* ====== Side table ====== */
    table{border-collapse:collapse;width:100%}
    th,td{padding:6px;border-bottom:1px solid #e9eef3;text-align:center;font-size:12px}
    th{background:#34495e;color:#fff;font-size:12px}
    .cat-row td{
      background:#f3f6f8;
      font-weight:900;
      text-align:left;
      padding:7px 10px;
      border-bottom:1px solid #dfe7ee;
    }
    .type-cell{color:#9aa6b2;font-size:10px}

    .hint{
      font-size:10px;
      color:var(--muted);
      padding:10px 12px;
      border-top:1px solid var(--line);
    }

    /* ====== Main tool (ver14-like) ====== */
    .tool-wrap{padding:12px}
    .tool-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background:#fbfcfe;
    }
    .tool-header h1{
      margin:0;
      font-size:15px;
      letter-spacing:.2px;
    }
    .print-btn{
      border:none;
      background:#2c3e50;
      color:#fff;
      border-radius:6px;
      padding:7px 10px;
      font-size:12px;
      cursor:pointer;
      font-weight:800;
    }
    .print-btn:hover{filter:brightness(.95)}

    .sel-basin{
      margin:10px 0 0 0;
      font-size:12px;
      color:#2c3e50;
      font-weight:800;
    }
    .sel-basin span{
      font-weight:900;
      color:#d35400;
    }

    .grid-2{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 900px){
      .grid-2{grid-template-columns:1fr}
    }

    .box{
      border:1px solid #dfe7ee;
      background:#fff;
      border-radius:10px;
      padding:10px;
    }
    .box h3{
      margin:0 0 8px 0;
      font-size:13px;
      font-weight:900;
    }
    .row{
      display:grid;
      grid-template-columns:1.2fr 1fr;
      gap:8px;
      align-items:center;
      margin:6px 0;
    }
    .row label{
      font-size:12px;
      color:#2c3e50;
      font-weight:800;
    }
    input,select{
      width:100%;
      font-size:12px;
      padding:6px 8px;
      border:1px solid #d6dde4;
      border-radius:6px;
      outline:none;
      background:#fff;
    }

    .panels-row{
      display:grid;
      grid-template-columns:1fr 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 1150px){
      .panels-row{grid-template-columns:1fr}
    }

    canvas{
      width:100%;
      border:1px dashed #cfd8e3;
      border-radius:8px;
      background:#fff;
    }

    .summary-box{
      display:grid;
      grid-template-columns:repeat(6, 1fr);
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 1150px){
      .summary-box{grid-template-columns:repeat(2,1fr)}
    }
    .stat{
      border:1px solid #e6edf3;
      background:#fbfdff;
      border-radius:10px;
      padding:8px;
      text-align:center;
    }
    .stat .k{font-size:11px;color:#6b7a86;font-weight:800}
    .stat .v{font-size:14px;font-weight:900;margin-top:4px}

    .status-ok{color:var(--ok);font-weight:900}
    .status-warn{color:var(--warn);font-weight:900}
    .status-fail{color:var(--danger);font-weight:900}

    /* Scenario table + risk colors */
    .table-wrap{
      margin-top:12px;
      border:1px solid #e6edf3;
      border-radius:10px;
      overflow:hidden;
    }
    .table-wrap table{width:100%}
    .table-wrap th{background:#34495e}
    .risk-safe{background:#eafaf1}
    .risk-warn{background:#fff7e6}
    .risk-orange{background:#ffe9d6}
    .risk-red{background:#ffe0e0}
    .risk-extreme{background:#ffd1d1}

    .footer-grid{
      display:grid;
      grid-template-columns:1.2fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 900px){
      .footer-grid{grid-template-columns:1fr}
    }
    .legend{
      border:1px solid #e6edf3;
      border-radius:10px;
      padding:10px;
      background:#fff;
    }
    .legend h4{margin:0 0 8px 0;font-size:12px;font-weight:900}
    .legend .item{
      display:flex;
      align-items:center;
      gap:8px;
      margin:6px 0;
      font-size:12px;
      font-weight:800;
      color:#2c3e50;
    }
    .swatch{
      width:18px;height:12px;border-radius:3px;border:1px solid rgba(0,0,0,.12);
    }

    .station-mini{
      display:grid;
      grid-template-columns:1fr 1fr 1fr;
      gap:8px;
      margin-top:8px;
    }
    @media (max-width: 900px){
      .station-mini{grid-template-columns:1fr}
    }
    .station-card{
      border:1px solid #e6edf3;
      border-radius:10px;
      padding:8px;
      background:#fbfdff;
    }
    .station-card .t{font-size:11px;color:#6b7a86;font-weight:900}
    .station-card .v{font-size:14px;font-weight:900;margin-top:3px}
    .station-actions{
      display:flex;
      gap:8px;
      margin-top:8px;
      flex-wrap:wrap;
    }

    /* ====== Map modal ====== */
    #mapModal{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:9999;
    }
    #mapCard{
      width:min(1100px, 96vw);
      height:min(700px, 88vh);
      background:#fff;
      border-radius:12px;
      overflow:hidden;
      box-shadow:var(--shadow);
      display:flex;
      flex-direction:column;
    }
    #mapTop{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      background:#fbfcfe;
      font-weight:900;
    }
    #mapBox{flex:1}

    /* ====== Loader ====== */
    #loader{
      display:none;
      font-size:12px;
      color:var(--muted);
      padding:8px 12px;
      border-top:1px solid var(--line);
    }

    /* ====== Print ====== */
    @media print{
      body{background:#fff}
      .side-panel{display:none!important}
      .app-shell{padding:0}
      .main-panel{box-shadow:none;border:none;border-radius:0}
      #mapModal{display:none!important}
      .no-print{display:none!important}
    }
  
  /* Watchlist chips + multi-station list */
  .chip{ display:inline-flex; align-items:center; gap:3px; padding:4px 8px; border-radius:999px; border:1px solid #cbd5e1; background:#ffffff; font-size:11px; cursor:pointer; }
  .chip b{ font-weight:600; }
  .chip button{ border:0; background:transparent; cursor:pointer; font-size:12px; line-height:1; color:#64748b; padding:0; }

  .chip.watch{ background:#fff7e6; border-color:#f1d27a; }
  .status-pill{ margin-top:8px; font-size:11px; font-weight:900; padding:7px 10px; border-radius:10px; border:1px solid #dfe7ee; background:#f8fafc; color:#475569; }
  .status-pill.status-ok{ background:#eafaf1; border-color:#bfe7cb; color:#1f7a3a; }
  .status-pill.status-warn{ background:#fff7e6; border-color:#f1d27a; color:#b35300; }
  .status-pill.status-neutral{ background:#f8fafc; border-color:#dfe7ee; color:#475569; }

  
  .meteo-msg{ font-size:10px; color:var(--muted); margin-top:6px; font-style:italic; }

  .multi-table{ width:100%; border:1px solid #cbd5e1; border-radius:10px; overflow:hidden; background:#fff; }
  .multi-row{
    display:grid;
    grid-template-columns: 1fr auto 1fr; /* name | timestamp | spacer -> timestamp stays centered */
    gap:8px;
    padding:6px 8px;
    border-top:1px solid #e2e8f0;
    align-items:center;
    font-size:11px;
  }
  .multi-row:first-child{ border-top:0; }
  .multi-name{ min-width:0; font-weight:600; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .multi-ts{ justify-self:center; text-align:center; color:#64748b; font-variant-numeric: tabular-nums; white-space:nowrap; }
  .multi-spacer{ }

    /* Multi-station extra list: include latest values chips */
    .multi-block{ border-top:1px solid #e2e8f0; padding:6px 8px; }
    .multi-block:first-child{ border-top:0; }
    .multi-block .multi-row{ padding:0; border-top:0; }
    .multi-latest{ margin-top:4px; }

    /* Compact chips for extra stations */
    .latest-chips.multi{ gap:2px; padding:0 0 2px 0; }
    .latest-chips.multi .chip{
      height:66px;
      padding:3px 2px;
      border-radius:12px;
    }
    .latest-chips.multi .chip .el{ font-size:8.8px; height:20px; }
    .latest-chips.multi .chip .en{ font-size:8.2px; height:18px; }
    .latest-chips.multi .chip .val{ font-size:10px; height:18px; }



    /* ====== NIREAS brand/logo ====== */
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .nireas-logo{
      height:42px;
      width:auto;
      border-radius:10px;
      background:#fff;
      padding:2px;
      border:1px solid #dfe7ee;
      box-shadow:0 6px 14px rgba(0,0,0,.10);
      flex:0 0 auto;
    }
    .brand h1{
      margin:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }


        /* Latest values chips (station monitor) */
    .latest-row{
      margin-top:6px;
      font-size:11px;
      line-height:1.2;
      color:#1f2a33;
      display:flex;
      flex-direction:column;   /* label on top, chips below */
      align-items:stretch;
      gap:2px;
    }
    .latest-row > b{
      display:block;
      white-space:nowrap;
      padding-top:0;
      flex:0 0 auto;
    }

/* Fit ALL chips inside the frame (no horizontal scrollbar) */
    .latest-chips{
      width:100%;
      flex:1 1 auto;
      display:grid;
      grid-template-columns: repeat(var(--chip-count, 14), minmax(0, 1fr));
      gap:3px;
      overflow:hidden;          /* no scrollbar */
      padding:1px 0 3px 0;
      max-width:100%;
      align-items:stretch;
    }

    /* Symmetric chip layout: Greek (top) / English (middle) / Value (bottom) */
    .latest-chips .chip{
      min-width:0;
      height:78px;              /* fixed height so values align */
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      padding:4px 3px;
      background:rgba(255,255,255,.92);
      border:1px solid #dfe7ee;
      border-radius:14px;
      box-shadow:0 1px 0 rgba(0,0,0,.03);
      text-align:center;
    }

    .latest-chips .chip .el,
    .latest-chips .chip .en,
    .latest-chips .chip .val{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:0 2px;
      word-break:break-word;
      hyphens:auto;
    }

    .latest-chips .chip .el{
      font-weight:900;
      font-size:9.6px;
      line-height:1.1;
      height:24px;              /* reserve space: keep symmetry */
    }
    .latest-chips .chip .en{
      font-weight:700;
      font-size:9.2px;
      line-height:1.1;
      height:20px;
      color:#6b7a86;
      margin-top:1px;
    }
    .latest-chips .chip .val{
      font-weight:900;
      font-size:11px;
      line-height:1.1;
      height:20px;
      font-variant-numeric:tabular-nums;
      margin-top:auto;          /* push value to bottom consistently */
      padding-bottom:1px;
    }


    /* De-emphasize empty/missing metrics while preserving alignment */
    .latest-chips .chip.empty{
      opacity:.55;
    }
    .latest-chips .chip.empty .val{
      font-weight:800;
    }

    /* Keep a hidden plain-text version (for copy/debug) */
    .latest-text{ display:none; }
    .nireas-text-logo{
      display:inline-block;
      font-weight:900;
      letter-spacing:.08em;
      font-size:12px;
      padding:4px 10px;
      border-radius:10px;
      background:rgba(255,255,255,.9);
      border:1px solid #dfe7ee;
      color:#0f172a;
    }

.status-stack{display:flex;flex-direction:column;gap:6px;margin-top:8px;}
</style>
</head>

<body>

<div class="app-shell">

  <!-- ================= LEFT: GitHub Data panel ================= -->
  <aside class="side-panel">
    <div class="panel-topbar">
      <div style="display:flex;align-items:center;gap:10px;white-space:nowrap;">
  Î Î·Î³Î® Î”ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ : <img class="nireas-logo" src="nireas_logo.png" alt="ÎÎ—Î¡Î•Î‘Î£" style="height:22px;padding:1px;border-radius:6px;" onerror="this.outerHTML='<span class=nireas-text-logo>NIREAS</span>'" />
</div>
      <button class="icon-btn" onclick="toggleCollapse('sideBody', this)">âˆ’</button>
    </div>

    <div id="sideBody">
      <div class="section">
        <div class="section-hdr">
          <div>ğŸ“¡ ÎœÎ•Î¤Î•Î©Î¡ÎŸÎ›ÎŸÎ“Î™ÎšÎŸÎ™ Î£Î¤Î‘Î˜ÎœÎŸÎ™</div>
          <button class="icon-btn" style="width:28px;height:24px" onclick="toggleCollapse('meteoBody', this)">âˆ’</button>
        </div>
        <div class="section-body" id="meteoBody">
                    <div style="font-size:11px;color:#6b7a86;margin-bottom:4px;">ÎšÏÏÎ¹Î¿Ï‚ Î£Ï„Î±Î¸Î¼ÏŒÏ‚</div>
          <div style="display:flex; gap:8px; align-items:center;">
            <select id="meteoStationSelect" style="flex:1">
              <option value="">Î•Ï€Î¹Î»Î¿Î³Î® ÎºÏÏÎ¹Î¿Ï… ÏƒÏ„Î±Î¸Î¼Î¿Ï...</option>
            </select>
            <button class="mini-btn btn-on" onclick="setPrimaryStation()" title="ÎŸÏÎ¹ÏƒÎ¼ÏŒÏ‚ Ï‰Ï‚ ÎšÏÏÎ¹Î¿Ï‚ Î£Ï„Î±Î¸Î¼ÏŒÏ‚ & Î¬Î¼ÎµÏƒÎ· Î»Î®ÏˆÎ·">â•</button>
            <button class="mini-btn btn-gray" onclick="clearPrimaryStation()" title="Î”Î¹Î±Î³ÏÎ±Ï†Î® ÎºÏÏÎ¹Î¿Ï… ÏƒÏ„Î±Î¸Î¼Î¿Ï">ğŸ§¹</button>
            <button class="mini-btn btn-map" onclick="openPrimaryWeb()" title="Î†Î½Î¿Î¹Î³Î¼Î± ÏƒÎµ Î½Î­Î± ÎºÎ±ÏÏ„Î­Î»Î±">ğŸ”— Web</button>
          </div>

          <div id="primaryStatusWrap" class="status-stack" style="margin-top:6px;">
            <div id="primaryStatus" class="status-pill status-neutral">ÎšÏÏÎ¹Î¿Ï‚: Î‘Î½Î±Î¼Î¿Î½Î®â€¦</div>
          </div>

          <div style="font-size:11px;color:#6b7a86;margin:10px 0 4px;">Î Î±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î·ÏƒÎ· (Ï€Î¿Î»Î»Î±Ï€Î»Î¿Î¯ ÏƒÏ„Î±Î¸Î¼Î¿Î¯)</div>
          <div style="display:flex; gap:8px; align-items:center;">
            <select id="monitorStationSelect" style="flex:1">
              <option value="">Î•Ï€Î¹Î»Î¿Î³Î® ÏƒÏ„Î±Î¸Î¼Î¿Ï Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î·ÏƒÎ·Ï‚...</option>
            </select>
            <button class="mini-btn btn-on" onclick="addToWatchlistFromMonitor()" title="Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· ÏƒÏ„Î¿Ï…Ï‚ Î•Ï€Î¹Ï€Î»Î­Î¿Î½ ÏƒÏ„Î±Î¸Î¼Î¿ÏÏ‚ & Î¬Î¼ÎµÏƒÎ· Î»Î®ÏˆÎ·">â•</button>
            <button class="mini-btn btn-gray" onclick="clearWatchlist()" title="ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î·ÏƒÎ·Ï‚">ğŸ§¹</button>
            <button class="mini-btn btn-map" onclick="openMonitorWeb()" title="Î†Î½Î¿Î¹Î³Î¼Î± ÏƒÎµ Î½Î­Î± ÎºÎ±ÏÏ„Î­Î»Î±">ğŸ”— Web</button>
          </div>

          <div id="meteoStatusWrap" class="status-stack" style="margin-top:6px;">
            <div id="extrasStatus" class="status-pill status-neutral">Î•Ï€Î¹Ï€Î»Î­Î¿Î½: Î‘Î½Î±Î¼Î¿Î½Î®â€¦</div>
          </div>
          <div id="meteoMsg" class="meteo-msg">â€”</div>

          <details class="no-print" style="margin-top:8px;">
            <summary style="cursor:pointer;font-size:11px;color:#6b7a86;">â• Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· custom ÏƒÏ„Î±Î¸Î¼Î¿Ï (Î¼Îµ URL)</summary>
            <div style="display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; align-items:center;">
              <input id="customStationName" placeholder="ÎŒÎ½Î¿Î¼Î± (Ï€.Ï‡. Î§Î‘Î›Î‘ÎÎ”Î¡Î™)" style="flex:1; min-width:220px; padding:8px; border:1px solid #dfe7ee; border-radius:10px; font-size:12px;">
              <input id="customStationUrl" placeholder="URL (Openâ€‘Meteo API Î® penteli link)" style="flex:2; min-width:320px; padding:8px; border:1px solid #dfe7ee; border-radius:10px; font-size:12px;">
              <button class="mini-btn btn-on" onclick="addCustomStation()" title="Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· custom ÏƒÏ„Î±Î¸Î¼Î¿Ï">â•</button>
              <button class="mini-btn btn-gray" onclick="clearCustomStations()" title="Î”Î¹Î±Î³ÏÎ±Ï†Î® custom Î»Î¯ÏƒÏ„Î±Ï‚ (Ï„Î¿Ï€Î¹ÎºÎ¬)">ğŸ§¹</button>
            </div>
            <div id="customStationMsg" style="font-size:10px;color:#6b7a86;margin-top:6px;font-style:italic;">Î‘Ï€Î¿Î¸Î·ÎºÎµÏÎµÏ„Î±Î¹ Ï„Î¿Ï€Î¹ÎºÎ¬ ÏƒÏ„Î¿Î½ browser.</div>
          </details>

          <div id="watchlistWrap" style="margin-top:8px;" class="no-print">
            <div id="watchlist" style="display:flex; flex-wrap:wrap; gap:6px;"></div>
          </div>


        </div>
      </div>

      <div class="section">
        <div class="section-hdr">
          <div>ğŸ“ Î‘Î¡Î§Î•Î™Î‘ Î•Î¡Î“ÎŸÎ¥ (GEOJSON)</div>
          <button class="icon-btn" style="width:28px;height:24px" onclick="toggleCollapse('filesBody', this)">âˆ’</button>
        </div>

        <div class="section-body" id="filesBody" style="padding:0">
          <div id="loader">Î¦ÏŒÏÏ„Ï‰ÏƒÎ· Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î±Ï€ÏŒ GitHubâ€¦</div>
          <table>
            <thead>
              <tr>
                <th style="text-align:left;padding-left:10px;">ÎŒÎ½Î¿Î¼Î±</th>
                <th>Î¤ÏÏ€Î¿Ï‚</th>
                <th>Î•Î½Î­ÏÎ³ÎµÎ¹Î±</th>
              </tr>
            </thead>
            <tbody id="fileRows"></tbody>
          </table>
        </div>
      </div>

      <div class="hint">
        <b>Load</b> = Ï†Î¿ÏÏ„ÏÎ½ÎµÎ¹ Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏƒÏ„Î¿ ÎºÏÏÎ¹Î¿ ÎµÏÎ³Î±Î»ÎµÎ¯Î¿ (Ï€.Ï‡. Î»ÎµÎºÎ¬Î½Î·).<br/>
        <b>Map</b> = Ï€ÏÎ¿ÎµÏ€Î¹ÏƒÎºÏŒÏ€Î·ÏƒÎ· ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î· (zoom) <b>Ï‡Ï‰ÏÎ¯Ï‚</b> Î±Î»Î»Î±Î³Î® On/Off.<br/>
        <b>On/Off</b> = ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÎ¹/ÎºÏÏÎ²ÎµÎ¹ layer (Ï€Î¿Î»Î»Î±Ï€Î»Î­Ï‚ ÎµÏ€Î¹Î»Î¿Î³Î­Ï‚).<br/>
      </div>
    </div>
  </aside>

  <!-- ================= RIGHT: Peq Screening Tool ================= -->
  <main class="main-panel">
    <div class="tool-header">
      <div class="brand">
        <img class="nireas-logo" src="nireas_logo.png" alt="ÎÎ—Î¡Î•Î‘Î£" onerror="this.outerHTML='<span class=nireas-text-logo>NIREAS</span>'" />
        <h1>Î”Î•Î™ÎšÎ¤Î•Î£ Î‘Î ÎŸÎšÎ¡Î™Î£Î—Î£ Î¤ÎŸÎ Î™ÎšÎ©Î Î›Î•ÎšÎ‘ÎÎ©Î Î‘Î ÎŸÎ¡Î¡ÎŸÎ—Î£ â€” Peq Screening Tool</h1>
      </div>
      <button class="print-btn no-print" onclick="window.print()">Î•ÎšÎ¤Î¥Î Î©Î£Î—</button>
    </div>

    <div class="tool-wrap">
      <div class="box" style="background:#97c9d1;border-color:#dfe7ee">
          <h3>ÎœÎ•Î¤Î•Î©Î¡ÎŸÎ›ÎŸÎ“Î™ÎšÎŸÎ£ Î£Î¤Î‘Î˜ÎœÎŸÎ£ (Monitor)</h3>
          <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;font-size:12px;">
            <div><b>Î£Ï„Î±Î¸Î¼ÏŒÏ‚:</b> <span id="stationName">â€”</span></div>
            <div><b>Timestamp:</b> <span id="stationTimestamp">â€”</span></div>
          </div>

          <div id="stationLatestRow" class="latest-row">
            <b>Î¤ÎµÎ»ÎµÏ…Ï„Î±Î¯ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚:</b>
            <div id="stationLatestChips" class="latest-chips">â€”</div>
            <span id="stationLatestValues" class="latest-text">â€”</span>
          </div>

          <div class="station-mini">
            <div class="station-card">
              <div class="t">Î’ÏÎ¿Ï‡Î® (mm/h)</div>
              <div class="v"><span id="stationRainRate">â€”</span></div>
            </div>
            <div class="station-card">
              <div class="t">Î”P (mm) <span id="stationTotalSrc" style="font-size:10px;color:#6b7a86"></span></div>
              <div class="v"><span id="stationDP">â€”</span></div>
            </div>
            <div class="station-card">
              <div class="t">R60 (mm)</div>
              <div class="v"><span id="stationR60">â€”</span></div>
            </div>
          </div>

          <div class="station-actions no-print">
            <button id="btnAutoStation" class="mini-btn btn-auto-default" onclick="applyAutoI()">Load</button>
            <button id="btnLiveStation" class="mini-btn btn-live-off" onclick="toggleLive()">Live</button>
            <button id="btnClearStation" class="mini-btn btn-gray" onclick="clearStationSeries()">ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚</button>
          </div>
          <div id="stationMsg" style="font-size:10px;color:#6b7a86;margin-top:6px;font-style:italic;">â€”</div>
          <div id="stationMultiList" style="margin-top:10px; display:none;"></div>
          <details id="seriesDetails" open style="margin-top:10px;">
            <summary style="cursor:pointer;font-size:11px;color:var(--ink);"><span id="seriesSummaryMain">Î™ÏƒÏ„Î¿ÏÎ¹ÎºÏŒ ÎšÏÏÎ¹Î¿Ï… Î£Ï„Î±Î¸Î¼Î¿Ï (12 Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯ÎµÏ‚)</span> <span id="seriesSummaryName" style="color:#6b7a86;margin-left:6px"></span></summary>
            <div id="stationSeriesList" class="series-list">â€”</div>
          </details>

        </div>

      <div class="sel-basin">Î•Ï€Î¹Î»ÎµÎ³Î¼Î­Î½Î· Î»ÎµÎºÎ¬Î½Î·: <span id="selectedBasinName">â€”</span></div>

      <div class="grid-2">
        <div class="box" style="background:#fff3cd;border-color:#f1d27a">
          <h3>Î£Î•ÎÎ‘Î¡Î™ÎŸ Î’Î¡ÎŸÎ§Î—Î£</h3>
          <div class="row">
            <label>ÎˆÎ½Ï„Î±ÏƒÎ· i (mm/h):</label>
            <input type="number" id="rainI" value="0" step="0.1">
          </div>
          <div class="row">
            <label>Î”Î¹Î¬ÏÎºÎµÎ¹Î± D (min):</label>
            <input type="number" id="rainD" value="0" step="0.1">
          </div>
          <div style="font-size:11px;color:#6b7a86;text-align:right;">
            *Î‘Î½ D=0 â†’ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Tc (ÎµÎ»Î¬Ï‡Î¹ÏƒÏ„Î¿ 5 min)
          </div>
        </div>

              </div>

      <div class="panels-row">

        <div class="box" style="background:#eaf7ff;border-color:#bfe4ff">
          <h3>1. Î“Î•Î©ÎœÎ•Î¤Î¡Î™Î‘</h3>
          <div class="row"><label>Î•Î¼Î²Î±Î´ÏŒÎ½ A (mÂ²):</label><input type="number" id="area" value="0" step="1"></div>
          <div class="row"><label>ÎœÎ®ÎºÎ¿Ï‚ ÏÎ¿Î®Ï‚ L (m):</label><input type="number" id="length" value="0" step="1"></div>
          <div class="row"><label>Î¥ÏˆÎ¿Î¼. Î´Î¹Î±Ï†Î¿ÏÎ¬ H (m):</label><input type="number" id="height" value="0" step="0.1"></div>
          <div class="row"><label>Î£Ï…Î½Ï„ÎµÎ»ÎµÏƒÏ„Î®Ï‚ C:</label><input type="number" id="coef" value="0.40" step="0.01"></div>

          <div style="margin-top:10px">
            <canvas id="basinCanvas" width="340" height="180"></canvas>
          </div>
        </div>

        <div class="box" style="background:#eef9f1;border-color:#cfeee0">
          <h3>2. Î£Î¥Î›Î›ÎŸÎ“Î— (Î¦Î¡Î•Î‘Î¤Î™Î‘)</h3>
          <div class="row"><label>Î Î»Î®Î¸Î¿Ï‚:</label><input type="number" id="drains" value="0" step="1"></div>
          <div class="row"><label>Î™ÎºÎ±Î½ÏŒÏ„Î·Ï„Î±/Ï†ÏÎµÎ¬Ï„Î¹Î¿ (mÂ³/s):</label><input type="number" id="drainCap" value="0" step="0.01"></div>
          <div style="font-size:11px;color:#6b7a86;margin-top:6px">
            *Qcap_Î´Î¹ÎºÏ„ÏÎ¿Ï… = Ï€Î»Î®Î¸Î¿Ï‚ Ã— Î¹ÎºÎ±Î½ÏŒÏ„Î·Ï„Î±/Ï†ÏÎµÎ¬Ï„Î¹Î¿
          </div>
        </div>

        <div class="box" style="background:#f6f0ff;border-color:#e3d5ff">
          <h3>3. Î”Î™ÎŸÎ”Î•Î¥Î£Î— (Î¡Î•ÎœÎ‘)</h3>
          <div class="row"><label>Î Î»Î¬Ï„Î¿Ï‚ Ï€Ï…Î¸Î¼Î­Î½Î± b (m):</label><input type="number" id="strWidth" value="0" step="0.1"></div>
          <div class="row"><label>Î Î»Î¬Î³Î¹ÎµÏ‚ ÎºÎ»Î¯ÏƒÎµÎ¹Ï‚ z (H:V):</label><input type="number" id="strZ" value="0" step="0.1"></div>
          <div class="row"><label>Î’Î¬Î¸Î¿Ï‚ h (m):</label><input type="number" id="strDepth" value="0" step="0.1"></div>

          <div class="row">
            <label>n (Manning):</label>
            <select id="strType">
              <option value="0.030">0.030 (Î£ÎºÏ…ÏÏŒÎ´ÎµÎ¼Î±)</option>
              <option value="0.035">0.035 (ÎœÎµÎ¹ÎºÏ„ÏŒ/Î¤ÏÎ±Ï‡Ï)</option>
              <option value="0.045">0.045 (Î¦Ï…ÏƒÎ¹ÎºÎ® ÎºÎ¿Î¯Ï„Î·)</option>
              <option value="0.060">0.060 (Î Î¿Î»Ï Ï„ÏÎ±Ï‡Ï)</option>
            </select>
          </div>
          
          <div class="row"><label>ÎœÎ®ÎºÎ¿Ï‚ (m) (0=L):</label><input type="number" id="strLen" value="0" step="1"></div>
          <div class="row"><label>Î Ï„ÏÏƒÎ· (m) (0=H):</label><input type="number" id="strDrop" value="0" step="0.1"></div>
          
          <div class="row">
            <label>ÎÏˆÎ¿Ï‚ Î½ÎµÏÎ¿Ï y (m):</label>
            <input type="number" id="strY" value="" step="0.01" placeholder="Auto">
          </div>
          <div class="station-actions no-print" style="margin-top:6px">
            <button class="mini-btn btn-gray" onclick="resetStrY()">Auto y</button>
            <button class="mini-btn btn-map" onclick="openMapModal()">Î§Î¬ÏÏ„Î·Ï‚</button>
          </div>

          <div style="margin-top:10px">
            <canvas id="channelCanvas" width="340" height="180"></canvas>
          </div>
        </div>

      </div>

      <div class="summary-box">
        <div class="stat"><div class="k">ÎšÎ»Î¯ÏƒÎ· S</div><div class="v" id="res-slope">â€”</div></div>
        <div class="stat"><div class="k">Tc (Kirpich)</div><div class="v" id="res-tc">â€”</div></div>
        <div class="stat"><div class="k" style="color:#d35400">Qpeak</div><div class="v" id="res-qsel">â€”</div></div>
        <div class="stat"><div class="k">Qcap Î”Î¹ÎºÏ„ÏÎ¿Ï…</div><div class="v" id="res-drains">â€”</div></div>
        <div class="stat"><div class="k">Qcap Î¡Î­Î¼Î±Ï„Î¿Ï‚</div><div class="v" id="res-stream">â€”</div></div>
        <div class="stat"><div class="k">ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚</div><div class="v" id="res-adequacy">â€”</div></div>
      </div>

      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>i (mm/h)</th>
              <th>D (min)</th>
              <th>P (mm)</th>
              <th>Qpeak (mÂ³/s)</th>
              <th>V (mÂ³)</th>
              <th>Î•Ï€Î¹ÎºÎ¹Î½Î´Ï…Î½ÏŒÏ„Î·Ï„Î±</th>
              <th>Î”Î¯ÎºÏ„Ï…Î¿</th>
              <th>Î¡Î­Î¼Î±</th>
            </tr>
          </thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>

      <div class="footer-grid">
        <div class="legend">
          <h4>Î£Î·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚</h4>
          <div style="font-size:12px;color:#2c3e50;font-weight:800;line-height:1.35">
            â€¢ Qpeak: ÎœÎ­Î¸Î¿Î´Î¿Ï‚ Rational (0.278Â·CÂ·iÂ·A_kmÂ²)<br/>
            â€¢ Tc: Kirpich (min) â€¢ D: Î±Î½ D=0 â†’ D= max(5, Tc)<br/>
            â€¢ Î¡Î­Î¼Î±: Manning ÏƒÎµ Ï„ÏÎ±Ï€ÎµÎ¶Î¿ÎµÎ¹Î´Î® Î´Î¹Î±Ï„Î¿Î¼Î® (b, z, h)<br/>
          </div>
        </div>

        <div class="legend">
          <h4>Î¥Ï€ÏŒÎ¼Î½Î·Î¼Î± (Peq = PÂ·C)</h4>
          <div class="item"><span class="swatch" style="background:#eafaf1"></span> Î§Î±Î¼Î·Î»Î® (&lt;10 mm)</div>
          <div class="item"><span class="swatch" style="background:#fff7e6"></span> ÎœÎ­Ï„ÏÎ¹Î± (10â€“25 mm)</div>
          <div class="item"><span class="swatch" style="background:#ffe9d6"></span> Î¥ÏˆÎ·Î»Î® (25â€“40 mm)</div>
          <div class="item"><span class="swatch" style="background:#ffe0e0"></span> Î Î¿Î»Ï Î¥ÏˆÎ·Î»Î® (40â€“60 mm)</div>
          <div class="item"><span class="swatch" style="background:#ffd1d1"></span> Î‘ÎºÏÎ±Î¯Î± (â‰¥60 mm)</div>
        </div>
      </div>

    </div>
  </main>

</div>

<!-- ================= Map Modal ================= -->
<div id="mapModal" class="no-print">
  <div id="mapCard">
    <div id="mapTop">
      <div>ğŸ—ºï¸ Î ÏÎ¿Î²Î¿Î»Î® Î§Î¬ÏÏ„Î· (Ï€Î¿Î»Î»Î±Ï€Î»Î¬ layers)</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button class="mini-btn btn-gray" onclick="turnAllOff()">Off ÏŒÎ»Î±</button>
        <button class="mini-btn btn-gray" onclick="closeMapModal()">ÎšÎ»ÎµÎ¯ÏƒÎ¹Î¼Î¿</button>
      </div>
    </div>
    <div id="mapBox"></div>
  </div>
</div>

<script>
/* ===================== CONFIG ===================== */
const GH_USER   = 'petrsanidas-ui';
const GH_REPO   = 'nireas';
const GH_BRANCH = 'main';
const API_TREE  = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/git/trees/${GH_BRANCH}?recursive=1`;
const RAW_URL   = `https://raw.githubusercontent.com/${GH_USER}/${GH_REPO}/${GH_BRANCH}/`;

let DATA_GROUPS = { boundaries: [], streams: [], basins: [] }; // NOTE ORDER
let SELECTED_GEO = null;
let SELECTED_BASIN_KEY = null;
let STATION_SELECT_BOUND = false; // bind dropdown change listener once
let MULTI_DETAILS_OPEN = true; // remember collapse state for "Î•Ï€Î¹Ï€Î»Î­Î¿Î½ ÏƒÏ„Î±Î¸Î¼Î¿Î¯"


/* ===== Map state (multi-layer) ===== */
let map = null;
let baseLayer = null;
const GEO_CACHE = new Map();       // path -> geojson
const LAYER_CACHE = new Map();     // path -> leaflet layer
const VISIBLE = new Set();         // paths currently "On"
let PREVIEW_LAYER = null;          // temporary layer for Map button preview

/* ===== Station monitor ===== */
const STATION_SERIES_MAX = 12;

// Per-station series contexts (do not mix histories across different primary stations)
const stationSeriesByKey  = Object.create(null);  // key -> array
const stationLastKeyByKey = Object.create(null);  // key -> last sample key
let currentStationKey = 'open-meteo';

let stationSeries = [];
let stationLastKey = null;

// initialize default context
stationSeriesByKey[currentStationKey] = stationSeries;
stationLastKeyByKey[currentStationKey] = stationLastKey;

let stationLiveOn = false;
const watchlist = new Map(); // url -> display name
let ACTIVE_PRIMARY_URL = '';
let ACTIVE_PRIMARY_NAME = '';

const LS_WATCHLIST_KEY = 'nireas_watchlist_v1';
const LS_CUSTOM_KEY   = 'nireas_customstations_v1';
const OPEN_METEO_TOKEN = '__OPEN_METEO__';


/* ===================== UI PERSISTENCE (keep values on refresh) ===================== */
const LS_UI_STATE_KEY = 'nireas_ui_state_v1';

let __uiSaveTimer = null;
function scheduleSaveUiState(){
  if(__uiSaveTimer) clearTimeout(__uiSaveTimer);
  __uiSaveTimer = setTimeout(saveUiStateNow, 250); // debounce
}

function getSavedUiState(){
  try{
    const raw = localStorage.getItem(LS_UI_STATE_KEY);
    if(!raw) return null;
    const st = JSON.parse(raw);
    return (st && typeof st === 'object') ? st : null;
  }catch(_){
    return null;
  }
}

function saveUiStateNow(){
  try{
    const state = {};

    // Save all inputs/selects/textareas that have an id
    document.querySelectorAll('input[id], select[id], textarea[id]').forEach(el => {
      const tag = el.tagName.toLowerCase();
      const type = (el.type || '').toLowerCase();

      // skip buttons
      if(tag === 'input' && (type === 'button' || type === 'submit' || type === 'reset')) return;

      if(type === 'checkbox' || type === 'radio'){
        state[el.id] = { t: type, v: !!el.checked };
      }else{
        state[el.id] = { t: 'value', v: el.value };
      }

      // keep manual flag for strY
      if(el.id === 'strY'){
        state.__strYManual = (el.dataset.manual === 'true');
      }
    });

    // Save selected basin + visible layers (GeoJSON project state)
    state.__selectedBasinKey = SELECTED_BASIN_KEY || null;
    state.__selectedBasinName = document.getElementById('selectedBasinName')?.innerText || null;
    state.__visiblePaths = Array.from(VISIBLE || []);

    localStorage.setItem(LS_UI_STATE_KEY, JSON.stringify(state));
  }catch(_){}
}

function restoreUiStateEarly(){
  // Only things needed BEFORE renderFileList(): VISIBLE (On/Off buttons)
  const st = getSavedUiState();
  if(!st) return;

  if(Array.isArray(st.__visiblePaths)){
    try{
      VISIBLE.clear();
      st.__visiblePaths.forEach(p => { if(p) VISIBLE.add(String(p)); });
    }catch(_){}
  }
}

function restoreUiFieldsFromState(st){
  const pendingSelects = [];
  const selectsToNotify = [];

  for(const [id, pack] of Object.entries(st)){
    if(id.startsWith('__')) continue;

    const el = document.getElementById(id);
    if(!el) continue;

    const tag = el.tagName.toLowerCase();
    const type = (el.type || '').toLowerCase();

    const t = (pack && typeof pack === 'object' && 't' in pack) ? pack.t : 'value';
    const v = (pack && typeof pack === 'object' && 'v' in pack) ? pack.v : pack;

    if(t === 'checkbox' || t === 'radio'){
      el.checked = !!v;
    }else{
      const val = String(v ?? '');
      if(tag === 'select'){
        const hasOpt = Array.from(el.options).some(o => o.value === val);
        if(!hasOpt) pendingSelects.push({ el, val });
        else el.value = val;
        selectsToNotify.push(el);
      }else{
        el.value = val;
      }
    }

    if(id === 'strY'){
      if(st.__strYManual) el.dataset.manual = 'true';
      else delete el.dataset.manual;
    }
  }

  // apply deferred selects now, and later once options are populated
  window.__NIREAS_PENDING_SELECTS = pendingSelects;
  window.__NIREAS_SELECTS_TO_NOTIFY = selectsToNotify;
  applyPendingRestores();
}

function applyPendingRestores(retries=6){
  const pending = window.__NIREAS_PENDING_SELECTS || [];
  if(pending.length){
    window.__NIREAS_PENDING_SELECTS = pending.filter(({el, val}) => {
      const hasOpt = Array.from(el.options).some(o => o.value === val);
      if(hasOpt) el.value = val;
      return !hasOpt;
    });
  }

  const notify = window.__NIREAS_SELECTS_TO_NOTIFY || [];
  if(notify.length){
    notify.forEach(el => {
      try{ el.dispatchEvent(new Event('change', { bubbles:true })); }catch(_){}
    });
    window.__NIREAS_SELECTS_TO_NOTIFY = [];
  }

  // If selects weren't ready yet, retry a few times (stations/lists load async)
  const remaining = (window.__NIREAS_PENDING_SELECTS || []).length;
  if(remaining && retries > 0){
    setTimeout(()=> applyPendingRestores(retries-1), 350);
  }
}

async function restoreUiStateLate(){
  // Restore last selected basin (GeoJSON) + all fields
  const st = getSavedUiState();
  if(!st) return;

  // 1) Restore basin first (so geometry/state exists), then re-apply saved fields so user's last values win
  if(st.__selectedBasinKey){
    try{
      const key = String(st.__selectedBasinKey);
      const name = st.__selectedBasinName || key.split('/').pop().replace('.geojson','');
      if(typeof loadToTool === 'function'){
        await loadToTool(key, name);
      }else{
        // at least restore label
        const el = document.getElementById('selectedBasinName');
        if(el) el.innerText = name;
        SELECTED_BASIN_KEY = key;
      }
    }catch(_){}
  }else if(st.__selectedBasinName){
    const el = document.getElementById('selectedBasinName');
    if(el) el.innerText = st.__selectedBasinName;
  }

  // 2) Restore all tool fields
  restoreUiFieldsFromState(st);

  // 3) Re-render file list so On/Off buttons match (in case state loaded after first render)
  try{ renderFileList(); }catch(_){}

  // 4) Ensure calculations reflect restored values
  try{ runMasterCalculation(); }catch(_){}
  try{ drawBasinPlan(); }catch(_){}
}

function bindPersistenceOnce(){
  if(window.__NIREAS_PERSIST_BOUND) return;
  window.__NIREAS_PERSIST_BOUND = true;

  // Save on any field change (captures most UI)
  document.addEventListener('input', (ev)=>{ if(ev.target && ev.target.id) scheduleSaveUiState(); }, true);
  document.addEventListener('change', (ev)=>{ if(ev.target && ev.target.id) scheduleSaveUiState(); }, true);

  // Ensure strY becomes manual when user types (bound once)
  const strYEl = document.getElementById('strY');
  if(strYEl && strYEl.dataset.boundManual !== '1'){
    strYEl.dataset.boundManual = '1';
    strYEl.addEventListener('input', ()=>{ strYEl.dataset.manual = 'true'; scheduleSaveUiState(); });
  }
}
/* =================== /UI PERSISTENCE =================== */


function setCustomMsg(msg){
  const el = document.getElementById('customStationMsg');
  if(el) el.textContent = msg;
}

function saveWatchlist(){
  try{
    const arr = Array.from(watchlist.entries()).map(([url,name]) => ({url, name}));
    localStorage.setItem(LS_WATCHLIST_KEY, JSON.stringify(arr));
  }catch(e){}
}

function loadWatchlist(){
  try{
    const raw = localStorage.getItem(LS_WATCHLIST_KEY);
    if(!raw) return;
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return;
    watchlist.clear();
    for(const it of arr){
      if(it && it.url){
        watchlist.set(String(it.url), String(it.name || it.url));
      }
    }
  }catch(e){}
}

function getCustomStations(){
  try{
    const raw = localStorage.getItem(LS_CUSTOM_KEY);
    if(!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}

function saveCustomStations(arr){
  try{
    localStorage.setItem(LS_CUSTOM_KEY, JSON.stringify(arr || []));
  }catch(e){}
}

function ensureCustomOptgroup(selectEl){
  if(!selectEl) return null;
  // try to find existing optgroup by label
  const groups = Array.from(selectEl.querySelectorAll('optgroup'));
  let grp = groups.find(g => (g.label || '').toLowerCase().includes('custom'));
  if(!grp){
    grp = document.createElement('optgroup');
    grp.label = 'Custom (Local)';
    selectEl.appendChild(grp);
  }
  return grp;
}

function upsertCustomOption(name, url){
  const normalized = normalizeStationUrl(url);
  if(!normalized) return;

  const ids = ['meteoStationSelect','monitorStationSelect'];
  ids.forEach(id=>{
    const sel = document.getElementById(id);
    if(!sel) return;

    const existing = Array.from(sel.options).find(o => o.value === normalized);
    if(existing){
      if(name && existing.textContent !== name) existing.textContent = name;
      return;
    }

    const grp = ensureCustomOptgroup(sel);
    const opt = document.createElement('option');
    opt.value = normalized;
    opt.textContent = (name || normalized.replace(/^https?:\/\//i,'').slice(0,60));
    opt.dataset.from = 'local';
    grp.appendChild(opt);
  });
}

function loadCustomStationsIntoSelect(){
  const list = getCustomStations();
  if(!list.length) return;
  for(const it of list){
    if(!it || !it.url) continue;
    upsertCustomOption(it.name || '', it.url);
  }
}

function addCustomStation(){
  const nameEl = document.getElementById('customStationName');
  const urlEl  = document.getElementById('customStationUrl');
  const name = (nameEl?.value || '').trim();
  const urlRaw = (urlEl?.value || '').trim();
  if(!urlRaw){
    setCustomMsg('Î”ÏÏƒÎµ URL ÏƒÏ„Î±Î¸Î¼Î¿Ï.');
    return;
  }
  const url = normalizeStationUrl(urlRaw);
  if(!url){
    setCustomMsg('ÎœÎ· Î­Î³ÎºÏ…ÏÎ¿ URL.');
    return;
  }

  // save to custom list
  const list = getCustomStations();
  const exists = list.some(x => String(x?.url||'') === url);
  if(!exists){
    list.push({name: name || url.replace(/^https?:\/\//i,'').slice(0,60), url});
    saveCustomStations(list);
  }

  // also add to dropdown + watchlist immediately
  upsertCustomOption(name, url);
  watchlist.set(url, name || url.replace(/^https?:\/\//i,'').slice(0,60));
  renderWatchlist();
  saveWatchlist();

  // clear inputs
  if(nameEl) nameEl.value = '';
  if(urlEl) urlEl.value = '';

  setCustomMsg('âœ… Î ÏÎ¿ÏƒÏ„Î­Î¸Î·ÎºÎµ (Ï„Î¿Ï€Î¹ÎºÎ¬).');

  // immediately fetch to show data
  fetchStationData();
}

function clearCustomStations(){
  const ok = confirm('ÎÎ± Î´Î¹Î±Î³ÏÎ±Ï†Î¿ÏÎ½ Î¿Î¹ custom ÏƒÏ„Î±Î¸Î¼Î¿Î¯ Ï€Î¿Ï… Î­Ï‡ÎµÎ¹Ï‚ Î±Ï€Î¿Î¸Î·ÎºÎµÏÏƒÎµÎ¹ Ï„Î¿Ï€Î¹ÎºÎ¬ ÏƒÏ„Î¿Î½ browser;');
  if(!ok) return;
  saveCustomStations([]);
  setCustomMsg('ğŸ§¹ ÎšÎ±Î¸Î±ÏÎ¯ÏƒÏ„Î·ÎºÎµ Î· custom Î»Î¯ÏƒÏ„Î±.');
  // Note: options will disappear on next reload of station list.
}

let stationLiveTimer = null;
let lastStationPayload = null;

// Hardening: clean up timers + catch unhandled async errors
window.addEventListener('pagehide', () => {
  try{ if(stationLiveTimer){ clearInterval(stationLiveTimer); stationLiveTimer = null; } }catch(_){}
});
window.addEventListener('beforeunload', () => {
  try{ if(stationLiveTimer){ clearInterval(stationLiveTimer); stationLiveTimer = null; } }catch(_){}
});
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  try{
    updateMeteoStatus('Î£Ï†Î¬Î»Î¼Î± (promise). Î”Î¿ÎºÎ¯Î¼Î±ÏƒÎµ Î¾Î±Î½Î¬.');
    setStationMsg('Î£Ï†Î¬Î»Î¼Î±: ' + (event.reason?.message || String(event.reason || 'unknown')));
  }catch(_){}
  event.preventDefault();
});

/* ===================== UI HELPERS ===================== */
function toggleCollapse(id, btn){
  const el = document.getElementById(id);
  if(!el) return;
  const isHidden = el.classList.toggle('collapsed');
  if(btn) btn.textContent = isHidden ? '+' : 'âˆ’';
}

function setStatusById(id, msg, level='neutral'){
  const el = document.getElementById(id);
  if(!el) return;
  el.innerText = msg;
  el.classList.remove('status-ok','status-warn','status-neutral');
  if(level==='ok') el.classList.add('status-ok');
  else if(level==='warn') el.classList.add('status-warn');
  else el.classList.add('status-neutral');
}
function updatePrimaryStatus(msg, level='neutral'){
  setStatusById('primaryStatus', msg, level);
}
function updateExtrasStatus(msg, level='neutral'){
  setStatusById('extrasStatus', msg, level);
}
// backward compatibility (sets both)
function updateMeteoStatus(msg, level='neutral'){
  // General informational message for the METEO section (does NOT touch the two independent status pills)
  const el = document.getElementById('meteoMsg');
  if(el){
    el.textContent = msg || 'â€”';
    return;
  }
  // fallback (older layouts)
  updatePrimaryStatus(msg, level);
  updateExtrasStatus(msg, level);
}
function setStationMsg(msg){
  const el = document.getElementById('stationMsg');
  if(el) el.innerText = msg;
}
function setTxt(id, txt){ const el=document.getElementById(id); if(el) el.textContent = txt; if(id==='stationName') updateSeriesSummaryName(); }
function updateSeriesSummaryName(){
  const el = document.getElementById('seriesSummaryName');
  if(!el) return;
  const name = (document.getElementById('stationName')?.textContent || '').trim();
  if(!name || name==='â€”'){
    el.textContent = '';
    return;
  }
  el.textContent = `â€¢ ${name}`;
}

// --- Station series context helpers (per *active* primary station) ---
// Active primary station applies ONLY after the user presses â•
function getPrimaryStationUrl(){
  return ACTIVE_PRIMARY_URL || '';
}
function getPrimaryStationName(){
  return ACTIVE_PRIMARY_NAME || '';
}
// Pending (dropdown) selection - not applied until â•
function getPendingPrimaryUrl(){
  return document.getElementById('meteoStationSelect')?.value || '';
}
function getPendingPrimaryName(){
  const sel = document.getElementById('meteoStationSelect');
  const url = sel?.value || '';
  if(!sel || !url) return '';
  return (sel.options[sel.selectedIndex]?.textContent || url).trim();
}
function getPrimaryStationKey(){
  const url = getPrimaryStationUrl();
  if(!url || url === OPEN_METEO_TOKEN) return 'open-meteo';
  return `url:${url}`;
}

function switchSeriesContext(newKey){
  const key = newKey || 'open-meteo';

  // save current context
  stationSeriesByKey[currentStationKey] = stationSeries;
  stationLastKeyByKey[currentStationKey] = stationLastKey;

  // load new context
  currentStationKey = key;
  stationSeries = stationSeriesByKey[currentStationKey] || [];
  stationLastKey = stationLastKeyByKey[currentStationKey]
    || (stationSeries.length ? stationSeries[stationSeries.length-1].key : null);

  // ensure stored
  stationSeriesByKey[currentStationKey] = stationSeries;
  stationLastKeyByKey[currentStationKey] = stationLastKey;

  // refresh readouts + list for the currently selected station
  updateStationReadouts();
}

function switchPrimarySeriesContext(){
  switchSeriesContext(getPrimaryStationKey());
}

function isFiniteNumber(x){ return typeof x === 'number' && isFinite(x); }
function num(val){
  if(val==null) return 0;
  const n = (typeof val === 'number') ? val : parseFloat(String(val).replace(',','.'));
  return isFiniteNumber(n) ? n : 0;
}
function getVal(id){ return num(document.getElementById(id)?.value); }
function setVal(id, v){
  const el = document.getElementById(id);
  if(!el) return;
  el.value = (v==null) ? "" : v;
}

function debounce(fn, wait=150){
  let t = null;
  return function(...args){
    if(t) clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), wait);
  };
}


/* ===================== GITHUB LOAD ===================== */
async function init(){
  document.getElementById('loader').style.display = 'block';
  try{
    const resp = await fetch(API_TREE);
    const data = await resp.json();
    if(data.message) throw new Error(data.message);

    const files = data.tree || [];

    // IMPORTANT: paths based on your current repo layout (from previous versions)
    // data/boundaries, data/streams, data/basins
    DATA_GROUPS.boundaries = files.filter(f => f.path.includes('data/boundaries/') && f.path.endsWith('.geojson'));
    DATA_GROUPS.streams    = files.filter(f => f.path.includes('data/streams/')    && f.path.endsWith('.geojson'));
    DATA_GROUPS.basins     = files.filter(f => f.path.includes('data/basins/')     && f.path.endsWith('.geojson'));

    restoreUiStateEarly();
    renderFileList();

    // Auto-populate stations dropdown from folder structure:
// - data/meteostations/api/*.txt      -> API / JSON
// - data/meteostations/weblinks/*.txt -> Web Links
const loaded = await fetchStationsFromFolders(files);

if(!loaded){
  // Backward-compatible fallback (older layouts)
  const stationFile =
    files.find(f => f.path === 'data/meteostations/weblinks/stations.txt') ||
    files.find(f => f.path.endsWith('/stations.txt') || f.path.endsWith('stations.txt')) ||
    files.find(f => f.path.endsWith('openmeteo.txt')) ||
    files.find(f => f.path.endsWith('ecmwf.txt'));

  if(stationFile) await fetchStations(stationFile.path);
  else {
    updateMeteoStatus("Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Î±ÏÏ‡ÎµÎ¯Î± ÏƒÏ„Î±Î¸Î¼ÏÎ½ (.txt) ÏƒÎµ data/meteostations/api Î® data/meteostations/weblinks");
    // safe fallback: keep dropdown empty
  }
}

    // Restore local custom stations + watchlist (no coding required)
    loadCustomStationsIntoSelect();
    loadWatchlist();
    renderWatchlist();

    // Keep values + selected GeoJSON after refresh
    bindPersistenceOnce();
    await restoreUiStateLate();

    bindInputs();
    runMasterCalculation();
    updateStationButtons();

    // If dropdown has a pending selection (but no ACTIVE yet), show "Î±Î½Î±Î¼Î¿Î½Î®"
    const sel = document.getElementById('meteoStationSelect');
    if(sel && sel.value && !getPrimaryStationUrl()){
      updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: Î‘Î½Î±Î¼Î¿Î½Î®â€¦', 'neutral');
    } else if(!getPrimaryStationUrl()){
      updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: (Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ ÎµÏ€Î¹Î»ÎµÎ³ÎµÎ¯)', 'warn');
    }

    // If no ACTIVE primary but watchlist exists, fetch extras immediately to show values
    if(!getPrimaryStationUrl() && watchlist.size){
      fetchStationData();
    }

  }catch(e){
    console.error(e);
    updateMeteoStatus("Î£Ï†Î¬Î»Î¼Î± GitHub: " + e.message);
  }finally{
    document.getElementById('loader').style.display = 'none';
  }
}

function renderFileList(){
  const tbody = document.getElementById('fileRows');
  tbody.innerHTML = '';

  const addCategory = (title, list, icon, color) => {
    const trHead = document.createElement('tr');
    trHead.className = 'cat-row';
    trHead.innerHTML = `<td colspan="3" style="color:${color}">${icon} ${title}</td>`;
    tbody.appendChild(trHead);

    list.forEach(f=>{
      const name = f.path.split('/').pop().replace('.geojson','');
      const tr = document.createElement('tr');

      const on = VISIBLE.has(f.path);
      tr.innerHTML = `
        <td style="text-align:left;padding-left:10px;">${name}</td>
        <td class="type-cell">GEOJSON</td>
        <td>
          <button class="mini-btn btn-load" onclick="loadToTool('${f.path}','${name}')">Load</button>
          <button class="mini-btn btn-map" onclick="previewOnMap('${f.path}','${name}')">Map</button>
          <button class="mini-btn ${on ? 'btn-on' : 'btn-off'}" id="btn-onoff-${cssSafe(f.path)}"
                  onclick="toggleLayer('${f.path}','${name}')">${on ? 'On' : 'Off'}</button>
        </td>
      `;
      tbody.appendChild(tr);
    });
  };

  // ORDER REQUESTED: boundaries -> streams -> basins
  addCategory("Î”Î¹Î¿Î¹ÎºÎ·Ï„Î¹ÎºÎ¬ ÎŒÏÎ¹Î±", DATA_GROUPS.boundaries, "ğŸ³ï¸", "#0f0f0f");
  addCategory("ğŸ’§ Î¥Î´ÏÎ¿Î³ÏÎ±Ï†Î¹ÎºÏŒ Î”Î¯ÎºÏ„Ï…Î¿", DATA_GROUPS.streams, "ğŸ’§", "#0f0f0f");
  addCategory("Î›ÎµÎºÎ¬Î½ÎµÏ‚ Î‘Ï€Î¿ÏÏÎ¿Î®Ï‚", DATA_GROUPS.basins, "ğŸï¸", "#0f0f0f");
}

function cssSafe(s){
  return btoa(unescape(encodeURIComponent(s))).replace(/=+/g,'').replace(/[+/]/g,'_');
}

async function fetchGeoJSON(path){
  if(GEO_CACHE.has(path)) return GEO_CACHE.get(path);
  const resp = await fetch(RAW_URL + path);
  if(!resp.ok) throw new Error("Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ: " + path);
  const json = await resp.json();
  GEO_CACHE.set(path, json);
  return json;
}

/* ===================== LOAD / MAP / ON-OFF LOGIC ===================== */
async function loadToTool(path, name){
  updateMeteoStatus("Î¦ÏŒÏÏ„Ï‰ÏƒÎ·: " + name + "â€¦");
  try{
    const gj = await fetchGeoJSON(path);

    // Only basins are expected to populate the tool inputs
    const isBasin = path.includes('data/basins/');
    if(isBasin){
      SELECTED_GEO = gj;
      SELECTED_BASIN_KEY = path;
      document.getElementById('selectedBasinName').innerText = name;
      if(typeof scheduleSaveUiState==='function') scheduleSaveUiState();

      // reset only if you want a clean start
      // (keep user's values if not present)
      const p = getPropsMerged(gj);

      if(p.area!=null)   setVal('area', p.area);
      if(p.length!=null) setVal('length', p.length);
      if(p.height!=null) setVal('height', p.height);
      if(p.coef!=null)   setVal('coef', p.coef);

      if(p.drains!=null)   setVal('drains', p.drains);
      if(p.drainCap!=null) setVal('drainCap', p.drainCap);

      if(p.strWidth!=null) setVal('strWidth', p.strWidth);
      if(p.strZ!=null)     setVal('strZ', p.strZ);
      if(p.strDepth!=null) setVal('strDepth', p.strDepth);

      if(p.strLen!=null)   setVal('strLen', p.strLen);
      if(p.strDrop!=null)  setVal('strDrop', p.strDrop);

      if(p.strType!=null){
        // if exact match exists in select
        const sel = document.getElementById('strType');
        const val = String(p.strType);
        if([...sel.options].some(o=>o.value===val)) sel.value = val;
      }

      // IMPORTANT: do NOT auto-open map; do NOT change On/Off here
      updateMeteoStatus(`Î¦Î¿ÏÏ„ÏÎ¸Î·ÎºÎµ ÏƒÏ„Î¿ ÎµÏÎ³Î±Î»ÎµÎ¯Î¿: ${name}`);
      runMasterCalculation();
      drawBasinPlan();
    } else {
      // non-basin: just cache + message
      updateMeteoStatus(`Î¦Î¿ÏÏ„ÏÎ¸Î·ÎºÎµ (cache): ${name}`);
    }

  }catch(e){
    alert("Î£Ï†Î¬Î»Î¼Î±: " + e.message);
    updateMeteoStatus("Î£Ï†Î¬Î»Î¼Î± Ï†ÏŒÏÏ„Ï‰ÏƒÎ·Ï‚.");
  }
}

// Map preview: opens map, zooms to that layer, WITHOUT changing On/Off
async function previewOnMap(path, name){
  try{
    openMapModal();
    const gj = await fetchGeoJSON(path);

    // remove old preview
    if(PREVIEW_LAYER && map){
      map.removeLayer(PREVIEW_LAYER);
      PREVIEW_LAYER = null;
    }

    const cat = categoryFromPath(path);
    PREVIEW_LAYER = L.geoJSON(gj, {
      style: styleForCategory(cat, true)
    }).addTo(map);

    try{
      map.fitBounds(PREVIEW_LAYER.getBounds(), { padding:[20,20] });
    }catch(_){}

    // ensure visible layers remain visible (do not alter VISIBLE)
    syncVisibleLayersToMap();
  }catch(e){
    console.error(e);
    alert("Map error: " + e.message);
  }
}

// On/Off toggle: NO map open; NO zoom; just state + map update if map is open
async function toggleLayer(path, name){
  const btn = document.getElementById('btn-onoff-' + cssSafe(path));
  const turningOn = !VISIBLE.has(path);

  if(turningOn) VISIBLE.add(path);
  else VISIBLE.delete(path);

  if(btn){
    btn.textContent = turningOn ? 'On' : 'Off';
    btn.classList.toggle('btn-on', turningOn);
    btn.classList.toggle('btn-off', !turningOn);
  }

  // only update map if already open
  if(map) syncVisibleLayersToMap();

  if(typeof scheduleSaveUiState==='function') scheduleSaveUiState();
}

// Turn everything off
function turnAllOff(){
  VISIBLE.clear();
  // update buttons
  document.querySelectorAll('button[id^="btn-onoff-"]').forEach(b=>{
    b.textContent = 'Off';
    b.classList.remove('btn-on');
    b.classList.add('btn-off');
  });
  if(map) syncVisibleLayersToMap();
}

/* ===================== MAP MODAL ===================== */
function openMapModal(){
  const modal = document.getElementById('mapModal');
  modal.style.display = 'flex';
  if(!map){
    map = L.map('mapBox', { zoomControl:true });
    baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
      maxZoom:19, attribution:'&copy; OpenStreetMap'
    }).addTo(map);
    map.setView([38.02, 23.80], 12);
  }
  setTimeout(()=>map.invalidateSize(), 80);
  syncVisibleLayersToMap();
}

function closeMapModal(){
  const modal = document.getElementById('mapModal');
  modal.style.display = 'none';
  // remove preview layer when closing (keeps On/Off layers persistent)
  if(PREVIEW_LAYER && map){
    map.removeLayer(PREVIEW_LAYER);
    PREVIEW_LAYER = null;
  }
}

function categoryFromPath(path){
  if(path.includes('data/boundaries/')) return 'boundaries';
  if(path.includes('data/streams/')) return 'streams';
  return 'basins';
}

function styleForCategory(cat, preview=false){
  if(cat==='boundaries'){
    return { color: preview ? '#e74c3c' : '#c0392b', weight: preview ? 3 : 2, fill:false, dashArray: preview ? '6 4' : null };
  }
  if(cat==='streams'){
    return { color: preview ? '#2ecc71' : '#2980b9', weight: preview ? 4 : 3, fill:false, dashArray: preview ? '6 4' : null };
  }
  // basins
  return { color: preview ? '#27ae60' : '#d35400', weight: preview ? 2 : 2, fill:true, fillOpacity: preview ? 0.12 : 0.18, dashArray: preview ? '6 4' : null };
}

// Ensure map shows exactly all "On" layers (plus preview if present)
async function syncVisibleLayersToMap(){
  if(!map) return;

  // remove cached layers not in VISIBLE
  for(const [path, layer] of LAYER_CACHE.entries()){
    if(!VISIBLE.has(path) && map.hasLayer(layer)){
      map.removeLayer(layer);
    }
  }

  // add layers in VISIBLE
  for(const path of VISIBLE){
    let layer = LAYER_CACHE.get(path);
    if(!layer){
      const gj = await fetchGeoJSON(path);
      const cat = categoryFromPath(path);
      layer = L.geoJSON(gj, { style: styleForCategory(cat, false) });
      LAYER_CACHE.set(path, layer);
    }
    if(!map.hasLayer(layer)) layer.addTo(map);
  }
}

/* ===================== PROPERTIES EXTRACTION ===================== */
function getPropsMerged(gj){
  // merge props from FeatureCollection[0].properties or root.properties
  let p = {};
  try{
    if(gj && gj.features && gj.features[0] && gj.features[0].properties){
      p = {...gj.features[0].properties};
    } else if(gj && gj.properties){
      p = {...gj.properties};
    }
  }catch(_){}

  // normalize keys commonly used
  // area
  const area = pickNumber(p, ['A','a','area','Area','A_m2','area_m2','AREA_M2']);
  const length = pickNumber(p, ['L','l','length','Length','L_m','length_m','LEN_M']);
  const height = pickNumber(p, ['H','h','height','Height','H_m','height_m','DROP_M']);
  const coef = pickNumber(p, ['C','c','coef','Coef','runoff','runoff_coef']);

  const drains = pickNumber(p, ['drains','DrainCount','n_drains']);
  const drainCap = pickNumber(p, ['drainCap','DrainCap','drain_cap']);

  const strWidth = pickNumber(p, ['strWidth','b','width']);
  const strZ = pickNumber(p, ['strZ','z','side_slope']);
  const strDepth = pickNumber(p, ['strDepth','h_depth','depth']);

  const strLen = pickNumber(p, ['strLen','stream_len','channel_len']);
  const strDrop = pickNumber(p, ['strDrop','stream_drop','channel_drop']);
  const strType = pickNumber(p, ['strType','manning','n']);

  const out = {};
  if(area!=null) out.area = area;
  if(length!=null) out.length = length;
  if(height!=null) out.height = height;
  if(coef!=null) out.coef = coef;

  if(drains!=null) out.drains = drains;
  if(drainCap!=null) out.drainCap = drainCap;

  if(strWidth!=null) out.strWidth = strWidth;
  if(strZ!=null) out.strZ = strZ;
  if(strDepth!=null) out.strDepth = strDepth;

  if(strLen!=null) out.strLen = strLen;
  if(strDrop!=null) out.strDrop = strDrop;
  if(strType!=null) out.strType = strType;

  return out;
}

function pickNumber(obj, keys){
  for(const k of keys){
    if(obj && obj[k]!=null && String(obj[k]).trim()!==''){
      const n = parseFloat(String(obj[k]).replace(',','.'));
      if(isFiniteNumber(n)) return n;
    }
  }
  return null;
}

/* ===================== METEO: Stations list ===================== */

function normalizeStationUrl(u){
  u = (u || '').trim();
  if(!u) return '';
  // allow protocol-relative or missing scheme
  if(/^https?:\/\//i.test(u)) return u;
  if(/^\/\//.test(u)) return 'https:' + u;
  return 'https://' + u;
}

function parseStationsText(text, sourcePath){
  const entries = [];
  const lines = (text || '').split(/\r?\n/);
  for(const raw of lines){
    const line = (raw || '').trim();
    if(!line) continue;
    if(line.startsWith('#') || line.startsWith('//')) continue;

    let name = '';
    let url  = line;

    if(line.includes('|')){
      const parts = line.split('|');
      name = (parts.shift() || '').trim();
      url  = parts.join('|').trim();
    }else{
      name = url.replace(/^https?:\/\//i,'').slice(0, 60);
    }

    url = normalizeStationUrl(url);
    if(!url) continue;
    if(!name) name = url.replace(/^https?:\/\//i,'').slice(0, 60);

    entries.push({ name, url, from: sourcePath || '' });
  }
  return entries;
}

function escapeHtml(s){
  return String(s ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
}

/* ===================== DATETIME: 24h formatting ===================== */
function pad2(n){ return String(n).padStart(2,'0'); }

function formatDateTime24(d){
  if(!(d instanceof Date) || isNaN(d.getTime())) return 'â€”';
  return `${pad2(d.getDate())}/${pad2(d.getMonth()+1)}/${d.getFullYear()}, ${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
}

function parseAnyDateTime(ts, opts){
  if(ts == null) return null;
  if(ts instanceof Date) return ts;
  const assumeUTC = !!(opts && opts.assumeUTC);
  const s0 = String(ts).trim();
  if(!s0) return null;

  // Normalize ISO strings with space separator
  const s = s0.replace(/^(\d{4}-\d{2}-\d{2})\s+(\d{1,2}:\d{2})/, '$1T$2');

  // If ISO includes explicit timezone (Z or +/-hh:mm), let Date parse it.
  if(/^\d{4}-\d{2}-\d{2}T\d{1,2}:\d{2}/.test(s) && /(Z|[+-]\d{2}:?\d{2})$/i.test(s)){
    const d = new Date(s);
    if(!isNaN(d.getTime())) return d;
  }

  // Greek / EU: dd/mm/yyyy, hh:mm(:ss) with optional Ï€.Î¼./Î¼.Î¼.
  if(s0.includes('/')){
    const m = s0.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:,)?\s*(\d{1,2}):(\d{2})(?::(\d{2}))?(?:\s*(Ï€\.Î¼\.|Î¼\.Î¼\.))?/i);
    if(m){
      const day = parseInt(m[1],10);
      const mon = parseInt(m[2],10) - 1;
      const year = parseInt(m[3],10);
      let hh = parseInt(m[4],10);
      const mi = parseInt(m[5],10);
      const ss = parseInt(m[6] || '0',10);
      const mer = (m[7] || '').toLowerCase();

      if(mer.includes('Î¼.Î¼') && hh < 12) hh += 12;
      if(mer.includes('Ï€.Î¼') && hh === 12) hh = 0;

      return new Date(year, mon, day, hh, mi, ss);
    }
  }

  // ISO-like without timezone: yyyy-mm-ddThh:mm(:ss)
  const m2 = s.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{1,2}):(\d{2})(?::(\d{2}))?/);
  if(m2){
    const year = parseInt(m2[1],10);
    const mon = parseInt(m2[2],10) - 1;
    const day = parseInt(m2[3],10);
    const hh = parseInt(m2[4],10);
    const mi = parseInt(m2[5],10);
    const ss = parseInt(m2[6] || '0',10);
    return assumeUTC ? new Date(Date.UTC(year, mon, day, hh, mi, ss)) : new Date(year, mon, day, hh, mi, ss);
  }

  // Fallback: let Date try (RFC formats, etc.)
  const d = new Date(s0);
  if(!isNaN(d.getTime())) return d;

  return null;
}

function ts24(ts, opts){
  if(ts == null) return 'â€”';
  const d = parseAnyDateTime(ts, opts);
  return d ? formatDateTime24(d) : String(ts);
}

function nowTs24(){
  return formatDateTime24(new Date());
}


function renderWatchlist(){
  const box = document.getElementById('watchlist');
  if(!box) return;
  box.innerHTML = '';
  if(!watchlist.size){
    box.innerHTML = '<span style="font-size:11px;color:#94a3b8;">(ÎºÎ±Î½Î­Î½Î±Ï‚ ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½Î¿Ï‚)</span>';
    return;
  }
  for(const [url,name] of watchlist.entries()){
    const chip = document.createElement('span');
    chip.className = 'chip watch';
    chip.innerHTML = `<b>${escapeHtml(name)}</b><button title="Î‘Ï†Î±Î¯ÏÎµÏƒÎ·" aria-label="Î‘Ï†Î±Î¯ÏÎµÏƒÎ·">âœ•</button>`;
    chip.querySelector('button').addEventListener('click', (e)=>{ 
      e.stopPropagation();
      watchlist.delete(url); 
      renderWatchlist(); 
      saveWatchlist();
      fetchStationData();
    });
    chip.addEventListener('click', ()=>{
      const sel = document.getElementById('monitorStationSelect');
      if(!sel) return;
      const opt = Array.from(sel.options).find(o => o.value === url);
      if(opt){ sel.value = url; sel.dispatchEvent(new Event('change')); }
    });
    box.appendChild(chip);
  }
}

function setPrimaryStation(){
  const sel = document.getElementById('meteoStationSelect');
  if(!sel) return;

  const url = sel.value || '';
  if(!url){
    updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: Î•Ï€Î­Î»ÎµÎ¾Îµ ÎºÏÏÎ¹Î¿ ÏƒÏ„Î±Î¸Î¼ÏŒ.', 'warn');
    return;
  }

  // Apply as ACTIVE primary (only on â•)
  const name = (sel.options[sel.selectedIndex]?.textContent || url).trim();
  ACTIVE_PRIMARY_URL = url;
  ACTIVE_PRIMARY_NAME = name;

  // Make sure histories do not mix across different primary stations
  switchSeriesContext(url === OPEN_METEO_TOKEN ? 'open-meteo' : `url:${url}`);

  // Immediate fetch for active primary + any extras
  updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: Î›Î®ÏˆÎ·â€¦', 'neutral');
  fetchStationData();
}

function clearPrimaryStation(){
  // Clear ACTIVE primary (and keep watchlist/extras intact)
  ACTIVE_PRIMARY_URL = '';
  ACTIVE_PRIMARY_NAME = '';

  const sel = document.getElementById('meteoStationSelect');
  if(sel){
    sel.value = '';
    sel.dispatchEvent(new Event('change'));
  }

  // Clear main station display on the right
  setTxt('stationName','â€”');
  setTxt('stationTimestamp','â€”');
  setTxt('stationRainRate','â€”');
  setTxt('stationDP','â€”');
  setTxt('stationR60','â€”');
  setLatestValuesDisplay(null,'â€”');
  setStationMsg('â€”');

  // Reset series context to default
  switchSeriesContext('open-meteo');

  // Update statuses
  if(watchlist.size){
    updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: (ÎºÎ±Î¸Î±ÏÎ¯ÏƒÏ„Î·ÎºÎµ)', 'neutral');
    fetchStationData(); // refresh extras only
  } else {
    updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: (Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ ÎµÏ€Î¹Î»ÎµÎ³ÎµÎ¯)', 'warn');
  }
}

function addToWatchlistFromMonitor(){
  const sel = document.getElementById('monitorStationSelect');
  if(!sel) return;
  const url = sel.value;
  if(!url){
    updateExtrasStatus('Î•Ï€Î¹Ï€Î»Î­Î¿Î½: Î•Ï€Î­Î»ÎµÎ¾Îµ ÏƒÏ„Î±Î¸Î¼ÏŒ Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î·ÏƒÎ·Ï‚.', 'warn');
    return;
  }
  const name = (sel.options[sel.selectedIndex]?.textContent || url).trim();
  watchlist.set(url, name);
  renderWatchlist();
  saveWatchlist();
  fetchStationData();
}
// backward compat (older UI)
function addToWatchlist(){
  return addToWatchlistFromMonitor();
}

function clearWatchlist(){
  watchlist.clear();
  renderWatchlist();
  saveWatchlist();

  // reset monitor dropdown back to placeholder
  const monSel = document.getElementById('monitorStationSelect');
  if(monSel){
    monSel.value = '';
    monSel.dispatchEvent(new Event('change'));
  }

  const multi = document.getElementById('stationMultiList');
  if(multi){ multi.style.display='none'; multi.innerHTML=''; }

  updateExtrasStatus('Î•Ï€Î¹Ï€Î»Î­Î¿Î½: (ÎºÎ±Î¸Î±ÏÎ¯ÏƒÏ„Î·ÎºÎ±Î½)', 'neutral');

  // also reset main station display if there is NO active primary
  if(!getPrimaryStationUrl()){
    setTxt('stationName','â€”');
    setTxt('stationTimestamp','â€”');
    setTxt('stationRainRate','â€”');
    setTxt('stationDP','â€”');
    setTxt('stationR60','â€”');
    setLatestValuesDisplay(null,'â€”');
    updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: (Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ ÎµÏ€Î¹Î»ÎµÎ³ÎµÎ¯)', 'warn');
  }
}

function getFetchTargets(){
  const primaryUrl = getPrimaryStationUrl();
  const primaryName = primaryUrl ? (getPrimaryStationName() || primaryUrl) : '';
  const targets = [];
  if(primaryUrl) targets.push({url: primaryUrl, name: primaryName, primary:true});
  for(const [url,name] of watchlist.entries()){
    if(url && url !== primaryUrl) targets.push({url, name, primary:false});
  }
  return targets;
}

function renderStationMultiList(results){
  const box = document.getElementById('stationMultiList');
  if(!box) return;
  const hasPrimary = !!getPrimaryStationUrl();
  const rest = hasPrimary ? (results||[]).slice(1) : (results||[]);
  if(!rest.length){ box.style.display='none'; box.innerHTML=''; return; }

const rows = rest.map(r=>{
    const ts = ts24(r.tsText || 'â€”');

    const items = makeLatestChipItems(r.latest);
    const chips = items.length
      ? items.map(it => `
          <div class="chip${it.v==='â€”' ? ' empty' : ''}">
            <div class="el">${escapeHtml(it.el)}</div>
            <div class="en">${escapeHtml(it.en)}</div>
            <div class="val">${escapeHtml(it.v)}</div>
          </div>`).join('')
      : `<div style="font-size:11px;color:#94a3b8;padding:4px 0;">â€”</div>`;

    const chipCount = items.length || 12;

    return `<div class="multi-block">
      <div class="multi-row">
        <div class="multi-name">${escapeHtml(r.name || 'â€”')}</div>
        <div class="multi-ts">${escapeHtml(ts)}</div>
        <div class="multi-spacer"></div>
      </div>
      <div class="multi-latest">
        <div class="latest-chips multi" style="--chip-count:${chipCount}">
          ${chips}
        </div>
      </div>
    </div>`;
  }).join('');

  box.style.display = 'block';

  const openAttr = MULTI_DETAILS_OPEN ? 'open' : '';
  box.innerHTML = `
    <details id="multiDetails" ${openAttr} style="margin-top:0;">
      <summary style="cursor:pointer;font-size:11px;color:var(--muted);margin-bottom:6px;">
        Î•Ï€Î¹Ï€Î»Î­Î¿Î½ ÏƒÏ„Î±Î¸Î¼Î¿Î¯
      </summary>
      <div class="multi-table">${rows}</div>
    </details>
  `;

  // persist open/closed state across re-renders (Load/Live refresh)
  const md = document.getElementById('multiDetails');
  if (md) {
    md.addEventListener('toggle', () => {
      MULTI_DETAILS_OPEN = md.open;
    }, { passive: true });
  }
}


async function readStationsFromTxt(path){
  const resp = await fetch(RAW_URL + path, { cache: 'no-store' });
  if(!resp.ok) throw new Error(`Î”ÎµÎ½ Ï†Î¿ÏÏ„ÏÎ¸Î·ÎºÎµ: ${path}`);
  const text = await resp.text();
  return parseStationsText(text, path);
}

function bindStationSelect(){
  if(STATION_SELECT_BOUND) return;
  const sel = document.getElementById('meteoStationSelect');
  if(!sel) return;

  sel.addEventListener('change', ()=>{
    const url = sel.value || '';
    if(!url){
      updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: (Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ ÎµÏ€Î¹Î»ÎµÎ³ÎµÎ¯)', 'warn');
      return;
    }
    // A new selection is pending until the user presses â•
    updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: Î‘Î½Î±Î¼Î¿Î½Î®â€¦', 'neutral');
  });

  STATION_SELECT_BOUND = true;
}

// New loader: populate dropdown from folder structure
async function fetchStationsFromFolders(files){
  try{
    const apiTxt = (files||[]).filter(p=>p.startsWith('data/meteostations/api/'));
    const webTxt = (files||[]).filter(p=>p.startsWith('data/meteostations/weblinks/'));
    if(apiTxt.length===0 && webTxt.length===0) return false;

    const apiItems = [];
    const webItems = [];
    const seen = new Set();

    const addItems = (arr, into)=>{
      for(const it of arr){
        const url = normalizeStationUrl(it.url || '');
        if(!url) continue;
        if(seen.has(url)) continue;
        seen.add(url);
        into.push({ name: (it.name||url).trim(), url, from: it.from || '' });
      }
    };

    for(const p of apiTxt){
      const items = await readStationsFromTxt(p);
      addItems(items.map(x=>({name:x.name,url:x.url,from:p})), apiItems);
    }
    for(const p of webTxt){
      const items = await readStationsFromTxt(p);
      addItems(items.map(x=>({name:x.name,url:x.url,from:p})), webItems);
    }

    const fill = (sel, placeholder)=>{
      if(!sel) return;
      sel.innerHTML = '';
      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = placeholder;
      sel.appendChild(opt0);

      const grpApi  = document.createElement('optgroup'); grpApi.label  = 'API / JSON';
      const grpLink = document.createElement('optgroup'); grpLink.label = 'Web / Links';

      // Built-in Open-Meteo (no external file required)
      {
        const opt = document.createElement('option');
        opt.value = OPEN_METEO_TOKEN;
        opt.textContent = 'Openâ€‘Meteo (Î§Î±Î»Î¬Î½Î´ÏÎ¹)';
        grpApi.appendChild(opt);
      }

      for(const it of apiItems){
        const opt = document.createElement('option');
        opt.value = it.url;
        opt.textContent = it.name;
        if(it.from) opt.dataset.from = it.from;
        grpApi.appendChild(opt);
      }
      for(const it of webItems){
        const opt = document.createElement('option');
        opt.value = it.url;
        opt.textContent = it.name;
        if(it.from) opt.dataset.from = it.from;
        grpLink.appendChild(opt);
      }

      sel.appendChild(grpApi);
      sel.appendChild(grpLink);
    };

    fill(document.getElementById('meteoStationSelect'), 'Î•Ï€Î¹Î»Î¿Î³Î® ÎºÏÏÎ¹Î¿Ï… ÏƒÏ„Î±Î¸Î¼Î¿Ï...');
    fill(document.getElementById('monitorStationSelect'), 'Î•Ï€Î¹Î»Î¿Î³Î® ÏƒÏ„Î±Î¸Î¼Î¿Ï Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î·ÏƒÎ·Ï‚...');

    bindStationSelect();
    updateMeteoStatus(`Î£Ï„Î±Î¸Î¼Î¿Î¯: API ${apiItems.length}, Web ${webItems.length}`, 'neutral');
    return true;
  }catch(err){
    console.warn('stations from folders failed', err);
    return false;
  }
}


async function fetchStations(path){
  try{
    const resp = await fetch(RAW_URL + path);
    const text = await resp.text();
    const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);

    const apiItems = [];
    const webItems = [];

    for(const line of lines){
      let name="", url=line;
      if(line.includes('|')){
        const parts = line.split('|');
        name = (parts[0]||'').trim();
        url  = (parts[1]||'').trim();
      }else{
        name = url.replace(/^https?:\/\//,'').slice(0,50);
      }
      url = normalizeStationUrl(url);
      if(!url) continue;

      const isApi = /(exec|api|json|\?)/i.test(url) && !/penteli\.meteo\.gr\/stations/i.test(url);
      (isApi ? apiItems : webItems).push({name: name || 'Station', url, from: path});
    }

    const fill = (sel, placeholder)=>{
      if(!sel) return;
      sel.innerHTML = '';
      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = placeholder;
      sel.appendChild(opt0);

      const grpApi  = document.createElement('optgroup'); grpApi.label  = 'API / JSON';
      const grpLink = document.createElement('optgroup'); grpLink.label = 'Web / Links';

      // Built-in Open-Meteo (no external file required)
      {
        const opt = document.createElement('option');
        opt.value = OPEN_METEO_TOKEN;
        opt.textContent = 'Openâ€‘Meteo (Î§Î±Î»Î¬Î½Î´ÏÎ¹)';
        grpApi.appendChild(opt);
      }

      for(const it of apiItems){
        const opt = document.createElement('option');
        opt.value = it.url;
        opt.textContent = it.name;
        opt.dataset.from = it.from;
        grpApi.appendChild(opt);
      }
      for(const it of webItems){
        const opt = document.createElement('option');
        opt.value = it.url;
        opt.textContent = it.name;
        opt.dataset.from = it.from;
        grpLink.appendChild(opt);
      }
      sel.appendChild(grpApi);
      sel.appendChild(grpLink);
    };

    fill(document.getElementById('meteoStationSelect'), 'Î•Ï€Î¹Î»Î¿Î³Î® ÎºÏÏÎ¹Î¿Ï… ÏƒÏ„Î±Î¸Î¼Î¿Ï...');
    fill(document.getElementById('monitorStationSelect'), 'Î•Ï€Î¹Î»Î¿Î³Î® ÏƒÏ„Î±Î¸Î¼Î¿Ï Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î·ÏƒÎ·Ï‚...');

    bindStationSelect();
  }catch(e){
    console.error(e);
  }
}

function openPrimaryWeb(){
  // Prefer pending selection (dropdown). If empty, fallback to active primary (if any).
  const url = getPendingPrimaryUrl() || getPrimaryStationUrl();
  if(!url){
    updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: Î”ÎµÎ½ Î­Ï‡ÎµÎ¹ ÎµÏ€Î¹Î»ÎµÎ³ÎµÎ¯ ÏƒÏ„Î±Î¸Î¼ÏŒÏ‚.', 'warn');
    return;
  }
  if(url === OPEN_METEO_TOKEN) { window.open('https://open-meteo.com/', '_blank'); return; }
  window.open(normalizeStationUrl(url), '_blank');
}
function openMonitorWeb(){
  // Open ALL monitored (watchlist) stations
  if(watchlist && watchlist.size){
    let opened = 0;
    const primaryUrl = getPrimaryStationUrl();
    for(const [url] of watchlist.entries()){
      if(primaryUrl && url === primaryUrl) continue;
      if(!url) continue;
      if(url === OPEN_METEO_TOKEN) { window.open('https://open-meteo.com/', '_blank'); opened++; continue; }
      window.open(normalizeStationUrl(url), '_blank');
      opened++;
    }
    if(opened) updateExtrasStatus(`Î•Ï€Î¹Ï€Î»Î­Î¿Î½: Î†Î½Î¿Î¹Î¾Î±Î½ ${opened} ÏƒÏ„Î±Î¸Î¼Î¿Î¯ ÏƒÎµ Î½Î­ÎµÏ‚ ÎºÎ±ÏÏ„Î­Î»ÎµÏ‚.`, 'ok');
    else updateExtrasStatus('Î•Ï€Î¹Ï€Î»Î­Î¿Î½: Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î­Î³ÎºÏ…ÏÎ± URLs.', 'warn');
    return;
  }

  // Fallback: open currently selected option (if any)
  const url = document.getElementById('monitorStationSelect')?.value || '';
  if(!url){
    updateExtrasStatus('Î•Ï€Î¹Ï€Î»Î­Î¿Î½: Î”ÎµÎ½ Î­Ï‡Î¿Ï…Î½ ÎµÏ€Î¹Î»ÎµÎ³ÎµÎ¯ ÏƒÏ„Î±Î¸Î¼Î¿Î¯ Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î·ÏƒÎ·Ï‚.', 'warn');
    return;
  }
  if(url === OPEN_METEO_TOKEN) { window.open('https://open-meteo.com/', '_blank'); return; }
  window.open(normalizeStationUrl(url), '_blank');
}
// backward compat
function openStationWeb(){ return openPrimaryWeb(); }

/* ===================== METEO: Fetch (API button) ===================== */

async function fetchStationDataSingle(url, label, updatePrimary){
  if(!url) return null;

  if(updatePrimary){
    // Primary station has its own context (do not mix histories across different sources)
    switchSeriesContext(url === OPEN_METEO_TOKEN ? 'open-meteo' : `url:${url}`);
    updatePrimaryStatus("ÎšÏÏÎ¹Î¿Ï‚: Î›Î®ÏˆÎ·â€¦", "neutral");
    setTxt('stationName', label || 'â€”');
  }

  try{
    // 0) Built-in Openâ€‘Meteo (token)
    if(url === OPEN_METEO_TOKEN){
      const r = await fetchOpenMeteoPayload();
      lastStationPayload = r;

      const latest = parseOpenMeteoLatest(r);
      const rr = (latest && latest.rr!=null) ? latest.rr : null;

      const tsRaw = latest?.__openMeteo?.time || r?.current?.time || new Date().toISOString();
      const ts = ts24(tsRaw);

      const seriesKey = updatePrimary ? currentStationKey : (`url:${url}`);
      const totalsSeries = deriveCumulativeTotalsForKey(seriesKey, latest?.__openMeteo?.amount);

      if(updatePrimary){
        updateStationMonitor(rr!=null ? rr : null, ts, totalsSeries);
        setLatestValuesDisplay(latest, buildLatestLine(latest));
        setStationMsg('Î›Î®ÏˆÎ· Î±Ï€ÏŒ Openâ€‘Meteo.');

        if(rr!=null){
          onNewStationSample(String(ts), ts, rr, label || 'Openâ€‘Meteo', totalsSeries);
          runMasterCalculation();
        }
      }

      if(!updatePrimary && rr!=null){
        storeSampleForKey(seriesKey, String(ts), ts, rr, label || 'Openâ€‘Meteo', totalsSeries, false);
      }

      return { ok:true, url, name: label, rr, tsText: ts, latest: latest, latestLine: buildLatestLine(latest) };
    }

    // 1) If URL is a JSON endpoint
    if(/json|api|exec|\?/i.test(url) && !/penteli\.meteo\.gr\/stations/i.test(url)){
      const r = await fetch(url, {cache:'no-store'}).then(res=>res.json());
      lastStationPayload = r;

      // Openâ€‘Meteo payload: fill ALL latest chips from the API
      if(isOpenMeteoPayload(r)){
        const latest = parseOpenMeteoLatest(r);
        const rr = (latest && latest.rr!=null) ? latest.rr : null;

        const tsRaw = latest?.__openMeteo?.time || extractTimestamp(r) || new Date().toISOString();
        const ts = ts24(tsRaw);

        const seriesKey = updatePrimary ? currentStationKey : (`url:${url}`);
        const totalsSeries = deriveCumulativeTotalsForKey(seriesKey, latest?.__openMeteo?.amount);

        if(updatePrimary){
          updateStationMonitor(rr!=null ? rr : null, ts, totalsSeries);
          setLatestValuesDisplay(latest, buildLatestLine(latest));
setStationMsg("Î›Î®ÏˆÎ· Î±Ï€ÏŒ Openâ€‘Meteo endpoint.");

          if(rr!=null){
            onNewStationSample(String(ts), ts, rr, label || 'Openâ€‘Meteo', totalsSeries);
            runMasterCalculation();
          }
        }

        if(!updatePrimary && rr!=null){
          storeSampleForKey(seriesKey, String(ts), ts, rr, label || 'Openâ€‘Meteo', totalsSeries, false);
        }

        return { ok:true, url, name: label, rr, tsText: ts, latest: latest, latestLine: buildLatestLine(latest) };
      }


      const rr = extractRainRate(r);
      const tsRaw = extractTimestamp(r) || new Date().toISOString();
      const ts = ts24(tsRaw);
      const totals = extractTotals(r);

      if(updatePrimary){
        setTxt('stationTimestamp', ts);
        setTxt('stationRainRate', (rr!=null && isFiniteNumber(rr)) ? rr.toFixed(1) : 'â€”');
        setTxt('stationTotalSrc', totals.totalSrc === 'storm' ? '(storm)' : totals.totalSrc === 'today' ? '(today)' : '');
        // compact Latest line for JSON endpoints (usually only rain metrics are available)
        {
          const parts = [];
          if(rr!=null && isFiniteNumber(rr)) parts.push(`Rate ${rr.toFixed(1)} mm/h`);
          if(totals && totals.today!=null) parts.push(`Today ${totals.today.toFixed(1)} mm`);
          if(totals && totals.storm!=null) parts.push(`Storm ${totals.storm.toFixed(1)} mm`);
          setLatestValuesDisplay({ rr: rr, today: (totals && totals.today!=null ? totals.today : null), storm: (totals && totals.storm!=null ? totals.storm : null) }, parts.length ? parts.join(' â€¢ ') : 'â€”');
        }
setStationMsg("Î›Î®ÏˆÎ· Î±Ï€ÏŒ endpoint.");

        if(rr!=null){
          // keep a sample for DP/R60 (only for primary)
          onNewStationSample(String(ts), ts, rr, label || 'Station', totals);
        }
        runMasterCalculation();
      }

      if(!updatePrimary && rr!=null){
        // keep separate history for this station even when it is in "Î•Ï€Î¹Ï€Î»Î­Î¿Î½ ÏƒÏ„Î±Î¸Î¼Î¿Î¯"
        storeSampleForKey(`url:${url}`, String(ts), ts, rr, label || 'Station', totals, false);
      }

      return { ok:true, url, name: label, rr, tsText: ts, latest: { rr: rr, today: (totals && totals.today!=null) ? totals.today : null, storm: (totals && totals.storm!=null) ? totals.storm : null }, latestLine: null };
    }

    // 2) If it's a meteo station page (Penteli)
    if(/penteli\.meteo\.gr\/stations/i.test(url)){
      const mirrorUrl = url.startsWith('https://') ? ('https://r.jina.ai/' + url) : ('https://r.jina.ai/https://' + url);
      const text = await fetch(mirrorUrl, {cache:'no-store'}).then(res=>res.text());

      const parsed = parseMeteoPageMinimal(text);
      const rr = parsed?.rr ?? null;
      const tsRaw = parsed?.timestamp ?? new Date().toISOString();
      const ts = ts24(tsRaw, {assumeUTC: !!parsed?.timestampIsUTC});
      const totals = parsed?.totals ?? null;

      if(updatePrimary){
        setTxt('stationTimestamp', ts);
        setTxt('stationRainRate', (rr!=null && isFiniteNumber(rr)) ? rr.toFixed(1) : 'â€”');
        setTxt('stationTotalSrc', totals && totals.totalSrc === 'storm' ? '(storm)' : totals && totals.totalSrc === 'today' ? '(today)' : '');
        setLatestValuesDisplay((parsed && parsed.latest) ? parsed.latest : null, (parsed && parsed.latestLine) ? parsed.latestLine : 'â€”');
setStationMsg("Î›Î®ÏˆÎ· Î¼Î­ÏƒÏ‰ mirror (r.jina.ai).");

        if(rr!=null){
          // keep a sample for DP/R60 (only for primary)
          onNewStationSample(String(ts), ts, rr, label || 'Station', totals);
        }
        runMasterCalculation();
      }

      if(!updatePrimary && rr!=null){
        // keep separate history for this station even when it is in "Î•Ï€Î¹Ï€Î»Î­Î¿Î½ ÏƒÏ„Î±Î¸Î¼Î¿Î¯"
        storeSampleForKey(`url:${url}`, String(ts), ts, rr, label || 'Station', totals, false);
      }

      return { ok:true, url, name: label, rr, tsText: ts, latest: (parsed && parsed.latest) ? parsed.latest : null, latestLine: (parsed && parsed.latestLine) ? parsed.latestLine : null };
    }

    if(updatePrimary){
      updatePrimaryStatus("ÎšÏÏÎ¹Î¿Ï‚: Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ API â€” Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¿ Web.", "warn");
      setStationMsg("ÎœÎ·-API ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Ï‚.");
    }
    return { ok:false, url, name: label, rr: null, tsText: 'â€”', latest: null, latestLine: null, error: "ÎœÎ· Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¹Î¶ÏŒÎ¼ÎµÎ½Î¿Ï‚ ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Ï‚ (ÏŒÏ‡Î¹ API)." };

  }catch(e){
    console.error(e);
    if(updatePrimary){
      updatePrimaryStatus("ÎšÏÏÎ¹Î¿Ï‚: Î£Ï†Î¬Î»Î¼Î± Î»Î®ÏˆÎ·Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½.", "warn");
      setStationMsg("Î£Ï†Î¬Î»Î¼Î±: " + e.message);
    }
    return { ok:false, url, name: label, rr: null, tsText: 'â€”', latest: null, latestLine: null, error: (e && e.message) ? e.message : String(e) };
  }
}

async function fetchStationData(){
  const targets = getFetchTargets();
  const hasPrimary = targets.some(t => t.primary);
  const extrasTargets = targets.filter(t => !t.primary);

  if(!targets.length){
    updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: Î•Ï€Î­Î»ÎµÎ¾Îµ ÎºÏÏÎ¹Î¿ ÏƒÏ„Î±Î¸Î¼ÏŒ.', 'warn');
    updateExtrasStatus('Î•Ï€Î¹Ï€Î»Î­Î¿Î½: Î ÏÏŒÏƒÎ¸ÎµÏƒÎµ ÎµÏ€Î¹Ï€Î»Î­Î¿Î½ ÏƒÏ„Î±Î¸Î¼Î¿ÏÏ‚.', 'neutral');
    return;
  }

  if(hasPrimary) updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: Î›Î®ÏˆÎ·â€¦', 'neutral');
  else updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: (Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ ÎµÏ€Î¹Î»ÎµÎ³ÎµÎ¯)', 'warn');

  if(extrasTargets.length) updateExtrasStatus('Î•Ï€Î¹Ï€Î»Î­Î¿Î½: Î›Î®ÏˆÎ·â€¦', 'neutral');
  else updateExtrasStatus('Î•Ï€Î¹Ï€Î»Î­Î¿Î½: (ÎºÎ±Î½Î­Î½Î±Ï‚)', 'neutral');

  const settled = await Promise.allSettled(
    targets.map(t => fetchStationDataSingle(t.url, t.name, t.primary))
  );

  const results = [];
  let primaryErr = null;
  let primaryOk = false;
  const extrasErrors = [];
  let extrasOkCount = 0;

  settled.forEach((s, i)=>{
    const t = targets[i];
    if(s.status === 'fulfilled'){
      if(s.value) results.push(s.value);

      if(t.primary){
        if(s.value && s.value.ok === true){
          primaryOk = true;
        } else {
          const er = (s.value && s.value.error) ? s.value.error : 'Î´ÎµÎ½ Ï†Î¿ÏÏ„ÏÎ¸Î·ÎºÎ±Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Î±';
          primaryErr = `${t.name || t.url}: ${er}`;
        }
      } else {
        if(s.value && s.value.ok === true){
          extrasOkCount += 1;
        } else {
          const nm = (s.value?.name || t.name || t.url);
          const er = (s.value?.error || 'Î´ÎµÎ½ Ï†Î¿ÏÏ„ÏÎ¸Î·ÎºÎ±Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Î±');
          extrasErrors.push(`${nm}: ${er}`);
        }
      }
    } else {
      const er = (s.reason && s.reason.message) ? s.reason.message : String(s.reason || 'ÏƒÏ†Î¬Î»Î¼Î±');
      if(t.primary){
        primaryErr = `${t.name || t.url}: ${er}`;
      } else {
        extrasErrors.push(`${t.name || t.url}: ${er}`);
      }
    }
  });

  renderStationMultiList(results);

  // Primary status
  if(hasPrimary){
    if(primaryOk && !primaryErr){
      updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: Î›Î®ÏˆÎ· OK', 'ok');
    } else {
      updatePrimaryStatus('ÎšÏÏÎ¹Î¿Ï‚: Î ÏÎ¿ÎµÎ¹Î´Î¿Ï€Î¿Î¯Î·ÏƒÎ·: ' + (primaryErr || 'Î´ÎµÎ½ Ï†Î¿ÏÏ„ÏÎ¸Î·ÎºÎ±Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Î±'), 'warn');
    }
  }

  // Extras status
  if(extrasTargets.length){
    if(extrasErrors.length){
      const short = extrasErrors.length <= 2
        ? extrasErrors.join(' â€¢ ')
        : (extrasErrors.slice(0,2).join(' â€¢ ') + ` â€¢ (+${extrasErrors.length-2} Î±ÎºÏŒÎ¼Î·)`);
      updateExtrasStatus('Î•Ï€Î¹Ï€Î»Î­Î¿Î½: Î ÏÎ¿ÎµÎ¹Î´Î¿Ï€Î¿Î¯Î·ÏƒÎ·: ' + short, 'warn');
    } else {
      updateExtrasStatus('Î•Ï€Î¹Ï€Î»Î­Î¿Î½: Î›Î®ÏˆÎ· OK', 'ok');
    }
  }
}

function getOpenMeteoCoords(){
  // default coords near Chalandri
  let lat = 38.02, lon = 23.80;

  // if selected basin exists, use first coordinate as quick proxy
  try{
    if(SELECTED_GEO && SELECTED_GEO.features && SELECTED_GEO.features[0]){
      const g = SELECTED_GEO.features[0].geometry;
      let c = null;
      if(g.type === 'Polygon') c = g.coordinates?.[0]?.[0];
      if(g.type === 'MultiPolygon') c = g.coordinates?.[0]?.[0]?.[0];
      if(g.type === 'LineString') c = g.coordinates?.[0];
      if(Array.isArray(c) && c.length>=2){
        lon = c[0]; lat = c[1];
      }
    }
  }catch(e){ /* ignore */ }

  return {lat, lon};
}

async function fetchOpenMeteoPayload(){
  const {lat, lon} = getOpenMeteoCoords();

  const currentVars = [
    'temperature_2m',
    'relative_humidity_2m',
    'apparent_temperature',
    'precipitation',
    'pressure_msl',
    'surface_pressure',
    'wind_speed_10m',
    'wind_direction_10m'
  ].join(',');

  const hourlyVars = ['dew_point_2m','precipitation'].join(',');
  const dailyVars  = ['rain_sum','precipitation_sum'].join(',');

  const u = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=${encodeURIComponent(dailyVars)}&hourly=${encodeURIComponent(hourlyVars)}&current=${encodeURIComponent(currentVars)}&timezone=Europe%2FAthens&forecast_days=1&forecast_hours=1&past_hours=1`;

  const r = await fetch(u, {cache:'no-store'}).then(res=>res.json());
  if(r && r.error) throw new Error(r.reason || 'Openâ€‘Meteo error');
  return r;
}

/* ===== Open-Meteo button (uses basin centroid if available) ===== */
async function fetchLiveMeteo(){
  updatePrimaryStatus("ÎšÏÏÎ¹Î¿Ï‚: Î›Î®ÏˆÎ·â€¦", "neutral");

  // Treat Open-Meteo as its own source/context
  switchSeriesContext('open-meteo');
  setTxt('stationName','Openâ€‘Meteo');

  try{
    const r = await fetchOpenMeteoPayload();

    const latest = parseOpenMeteoLatest(r);
    const rr = latest?.rr ?? null;
    const tsRaw = latest?.__openMeteo?.time || r?.current?.time || new Date().toISOString();
    const ts = ts24(tsRaw);

    // Build derived cumulative totals so Î”P/R60 work
    const totalsSeries = deriveCumulativeTotalsForKey(currentStationKey, latest?.__openMeteo?.amount);

    updateStationMonitor(rr!=null ? rr : null, ts, totalsSeries);
    setLatestValuesDisplay(latest, buildLatestLine(latest));
    updatePrimaryStatus("ÎšÏÏÎ¹Î¿Ï‚: Î›Î®ÏˆÎ· OK", "ok");

    if(rr!=null){
      onNewStationSample(String(ts), ts, rr, 'Openâ€‘Meteo', totalsSeries);
      setStationMsg("Live Î±Ï€ÏŒ Openâ€‘Meteo (current + hourly + daily).");
      runMasterCalculation();
    } else {
      setStationMsg("Openâ€‘Meteo: Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î· Ï„Î¹Î¼Î® Î²ÏÎ¿Ï‡ÏŒÏ€Ï„Ï‰ÏƒÎ·Ï‚.");
    }

  }catch(e){
    console.error(e);
    updatePrimaryStatus("ÎšÏÏÎ¹Î¿Ï‚: Î ÏÎ¿ÎµÎ¹Î´Î¿Ï€Î¿Î¯Î·ÏƒÎ·: Î£Ï†Î¬Î»Î¼Î± Openâ€‘Meteo", "warn");
    setStationMsg("Î£Ï†Î¬Î»Î¼Î± Openâ€‘Meteo: " + e.message);
  }
}

/* ===================== Station monitor logic ===================== */
function extractRainRate(obj){
  // common keys (explicit mm/h)
  const keys = ['rainRate_mmh','rain_rate','rainRate','i','intensity','precipitation_rate','precip_rate'];
  for(const k of keys){
    if(obj && obj[k]!=null){
      const n = parseFloat(String(obj[k]).replace(',','.'));
      if(isFiniteNumber(n)) return n;
    }
  }

  // Open-Meteo: prefer an explicit rate if present
  const n2 = obj?.current?.precipitation_rate;
  if(isFiniteNumber(n2)) return n2;

  // Open-Meteo: derive rate from precipitation amount and interval (seconds)
  const p = obj?.current?.precipitation;
  const interval = obj?.current?.interval;
  if(isFiniteNumber(p) && isFiniteNumber(interval) && interval > 0){
    return (p * 3600) / interval;
  }

  // Fallback: use hourly precipitation at the nearest hour (treated as mm/h)
  const t = obj?.current?.time;
  if(t && Array.isArray(obj?.hourly?.time) && Array.isArray(obj?.hourly?.precipitation)){
    const idx = nearestTimeIndex(t, obj.hourly.time);
    const hp = obj.hourly.precipitation[idx];
    if(isFiniteNumber(hp)) return hp;
  }

  return null;
}
function extractTimestamp(obj){
  const keys = ['station_ts','timestamp','time','datetime','dateTime','lastUpdate','last_update'];
  for(const k of keys){
    if(obj && obj[k]) return String(obj[k]).trim();
  }
  // open-meteo
  if(obj?.current?.time) return String(obj.current.time);
  return null;
}
function extractTotals(obj){
  const t = {};
  t.today = pickNumber(obj, ['rainToday_mm','rain_today_mm','todayRain','today_rain']);
  t.storm = pickNumber(obj, ['stormTotal_mm','storm_total_mm','rainStorm','storm_total']);
  if(t.storm!=null){ t.total=t.storm; t.totalSrc='storm'; }
  else if(t.today!=null){ t.total=t.today; t.totalSrc='today'; }
  else { t.total=null; t.totalSrc=null; }
  return t;
}

/* ===================== Openâ€‘Meteo helpers ===================== */
function isOpenMeteoPayload(obj){
  return !!(obj && obj.current && (
    obj.current.temperature_2m != null ||
    obj.current.relative_humidity_2m != null ||
    obj.current.apparent_temperature != null ||
    obj.current.pressure_msl != null ||
    obj.current.wind_speed_10m != null
  ));
}

function degToCompass(deg){
  if(deg == null || !isFiniteNumber(deg)) return '';
  const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
  const d = ((Number(deg) % 360) + 360) % 360;
  const i = Math.round(d / 22.5) % 16;
  return dirs[i];
}

function nearestTimeIndex(targetTs, timeArr){
  if(!Array.isArray(timeArr) || !timeArr.length) return 0;
  const t0 = parseAnyDateTime(targetTs);
  if(!t0) return 0;

  let bestI = 0;
  let best = Infinity;
  const t0ms = t0.getTime();

  for(let i=0;i<timeArr.length;i++){
    const d = parseAnyDateTime(timeArr[i]);
    if(!d) continue;
    const diff = Math.abs(d.getTime() - t0ms);
    if(diff < best){
      best = diff;
      bestI = i;
    }
  }
  return bestI;
}

function deriveCumulativeTotalsForKey(seriesKey, amount){
  // Builds a local (session-only) cumulative so Î”P/R60 can work even when the API
  // does not provide storm/today running totals.
  if(amount == null || !isFiniteNumber(amount)) return null;

  const key = seriesKey || currentStationKey || 'open-meteo';
  const series = stationSeriesByKey[key] || [];
  const prev = series.length ? series[series.length-1] : null;
  const prevTotal = (prev && prev.total!=null && isFiniteNumber(prev.total)) ? prev.total : 0;
  const newTotal = prevTotal + Number(amount);

  return { total: newTotal, totalSrc: 'storm', today: null, storm: null };
}

function parseOpenMeteoLatest(obj){
  const r = obj || {};
  const cur = r.current || {};
  const latest = {};

  latest.temp = isFiniteNumber(cur.temperature_2m) ? Number(cur.temperature_2m) : null;
  latest.hum  = isFiniteNumber(cur.relative_humidity_2m) ? Number(cur.relative_humidity_2m) : null;

  // Dew point: prefer current if present, else nearest hourly
  if(isFiniteNumber(cur.dew_point_2m)){
    latest.dew = Number(cur.dew_point_2m);
  } else if(Array.isArray(r?.hourly?.time) && Array.isArray(r?.hourly?.dew_point_2m)){
    const idx = nearestTimeIndex(cur.time || r.hourly.time[r.hourly.time.length-1], r.hourly.time);
    const v = r.hourly.dew_point_2m[idx];
    latest.dew = isFiniteNumber(v) ? Number(v) : null;
  } else {
    latest.dew = null;
  }

  // Wind: speed + compass from degrees
  const ws = isFiniteNumber(cur.wind_speed_10m) ? Number(cur.wind_speed_10m) : null;
  const wd = isFiniteNumber(cur.wind_direction_10m) ? Number(cur.wind_direction_10m) : null;
  if(ws != null){
    const dir = (wd != null) ? degToCompass(wd) : '';
    latest.wind = `${ws.toFixed(1)} km/h${dir ? (' ' + dir) : ''}`;
  }

  // Pressure
  latest.baro = isFiniteNumber(cur.pressure_msl) ? Number(cur.pressure_msl)
              : (isFiniteNumber(cur.surface_pressure) ? Number(cur.surface_pressure) : null);

  // Rain (day totals): use daily rain_sum (rain only) and precipitation_sum (all)
  const d = r.daily || {};
  const dayRain = (Array.isArray(d.rain_sum) && isFiniteNumber(d.rain_sum[0])) ? Number(d.rain_sum[0]) : null;
  const dayPrec = (Array.isArray(d.precipitation_sum) && isFiniteNumber(d.precipitation_sum[0])) ? Number(d.precipitation_sum[0]) : null;
  latest.today = (dayRain != null) ? dayRain : dayPrec;
  latest.storm = (dayPrec != null) ? dayPrec : latest.today;

  // Rain rate: derive from current precipitation amount + interval
  let rr = null;
  let amount = null;
  if(isFiniteNumber(cur.precipitation)){
    amount = Number(cur.precipitation);
    if(isFiniteNumber(cur.interval) && Number(cur.interval) > 0){
      rr = (amount * 3600) / Number(cur.interval);
    } else {
      rr = amount; // fallback (treat as mm/h)
    }
  }
  // fallback: use nearest hourly precipitation (treated as mm/h)
  if(rr == null && Array.isArray(r?.hourly?.time) && Array.isArray(r?.hourly?.precipitation)){
    const idx = nearestTimeIndex(cur.time || r.hourly.time[r.hourly.time.length-1], r.hourly.time);
    const hp = r.hourly.precipitation[idx];
    if(isFiniteNumber(hp)) rr = Number(hp);
  }
  latest.rr = rr;

  // Monthly / yearly not available from forecast endpoint by default
  latest.month = null;
  latest.year  = null;

  // Apparent temperature â†’ show as Wind Chill (cold) or Heat Index (warm)
  const app = isFiniteNumber(cur.apparent_temperature) ? Number(cur.apparent_temperature) : null;
  if(app != null){
    if(latest.temp != null && latest.temp >= 18){
      latest.heat = app;
      latest.chill = null;
    } else {
      latest.chill = app;
      latest.heat = null;
    }
  } else {
    latest.chill = null;
    latest.heat = null;
  }

  latest.__openMeteo = {
    time: cur.time || null,
    interval: isFiniteNumber(cur.interval) ? Number(cur.interval) : null,
    amount: amount
  };

  return latest;
}


function pickMatchFromText(text, rx, group=1){
  const m = text.match(rx);
  return m ? String(m[group]).trim() : null;
}
function pickNumFromText(text, rx, group=1){
  const s = pickMatchFromText(text, rx, group);
  if(s == null) return null;
  const n = parseFloat(String(s).replace(',','.'));
  return isFiniteNumber(n) ? n : null;
}
function fmtNum(n, dec=1){
  return (n!=null && isFiniteNumber(n)) ? Number(n).toFixed(dec) : null;
}
function buildLatestLine(lat){
  if(!lat) return null;
  const parts = [];
  if(lat.temp!=null) parts.push(`T ${fmtNum(lat.temp,1)}Â°C`);
  if(lat.hum!=null) parts.push(`RH ${fmtNum(lat.hum,0)}%`);
  if(lat.dew!=null) parts.push(`Td ${fmtNum(lat.dew,1)}Â°C`);
  if(lat.wind) parts.push(`Wind ${lat.wind}`);
  if(lat.baro!=null) parts.push(`P ${fmtNum(lat.baro,1)} hPa`);
  if(lat.today!=null) parts.push(`Today ${fmtNum(lat.today,1)} mm`);
  if(lat.rr!=null) parts.push(`Rate ${fmtNum(lat.rr,1)} mm/h`);
  if(lat.storm!=null) parts.push(`Storm ${fmtNum(lat.storm,1)} mm`);
  if(lat.month!=null) parts.push(`Month ${fmtNum(lat.month,1)} mm`);
  if(lat.year!=null) parts.push(`Year ${fmtNum(lat.year,1)} mm`);
  if(lat.chill!=null) parts.push(`Chill ${fmtNum(lat.chill,1)}Â°C`);
  if(lat.heat!=null) parts.push(`Heat ${fmtNum(lat.heat,1)}Â°C`);
return parts.length ? parts.join(' â€¢ ') : null;
}



function makeLatestChipItems(lat){
  // Return a FIXED, ordered set of chips so all station rows align perfectly.
  // If a metric is missing, we keep its slot and show "â€”" (styled as .empty).
  if(!lat || typeof lat !== 'object') return [];


  const vTemp  = (lat.temp  != null) ? `${fmtNum(lat.temp,1)} Â°C`  : 'â€”';
  const vHum   = (lat.hum   != null) ? `${fmtNum(lat.hum,0)} %`    : 'â€”';
  const vDew   = (lat.dew   != null) ? `${fmtNum(lat.dew,1)} Â°C`   : 'â€”';
  const vWind  = (lat.wind  != null && String(lat.wind).trim()) ? String(lat.wind).trim() : 'â€”';
  const vBaro  = (lat.baro  != null) ? `${fmtNum(lat.baro,1)} hPa` : 'â€”';

  const vToday = (lat.today != null) ? `${fmtNum(lat.today,1)} mm` : 'â€”';
  const vRr    = (lat.rr    != null) ? `${fmtNum(lat.rr,1)} mm/h`  : 'â€”';
  const vStorm = (lat.storm != null) ? `${fmtNum(lat.storm,1)} mm` : 'â€”';
  const vMonth = (lat.month != null) ? `${fmtNum(lat.month,1)} mm` : 'â€”';
  const vYear  = (lat.year  != null) ? `${fmtNum(lat.year,1)} mm`  : 'â€”';

  const vChill = (lat.chill != null) ? `${fmtNum(lat.chill,1)} Â°C` : 'â€”';
  const vHeat  = (lat.heat  != null) ? `${fmtNum(lat.heat,1)} Â°C`  : 'â€”';

  return [
    { el:'Î˜ÎµÏÎ¼Î¿ÎºÏÎ±ÏƒÎ¯Î±',        en:'Temperature',  v: vTemp  },
    { el:'Î¥Î³ÏÎ±ÏƒÎ¯Î±',            en:'Humidity',     v: vHum   },
    { el:'Î£Î·Î¼ÎµÎ¯Î¿ Î”ÏÏŒÏƒÎ¿Ï…',      en:'Dew Point',    v: vDew   },
    { el:'Î†Î½ÎµÎ¼Î¿Ï‚',             en:'Wind',         v: vWind  },
    { el:'Î’Î±ÏÏŒÎ¼ÎµÏ„ÏÎ¿',          en:'Barometer',    v: vBaro  },

    { el:'Î£Î·Î¼ÎµÏÎ¹Î½ÏŒÏ‚ Î¥ÎµÏ„ÏŒÏ‚',    en:"Today's Rain", v: vToday },
    { el:'Î¡Î±Î³Î´Î±Î¹ÏŒÏ„Î·Ï„Î±',        en:'Rain Rate',    v: vRr    },
    { el:'Î¤ÏÎ­Ï‡Î¿Ï…ÏƒÎ± ÎºÎ±ÎºÎ¿ÎºÎ±Î¹ÏÎ¯Î±',en:'Storm Total',  v: vStorm },
    { el:'ÎœÎ·Î½Î¹Î±Î¯Î¿Ï‚ Î¥ÎµÏ„ÏŒÏ‚',     en:'Monthly Rain', v: vMonth },
    { el:'Î•Ï„Î®ÏƒÎ¹Î¿Ï‚ Î¥ÎµÏ„ÏŒÏ‚',      en:'Yearly Rain',  v: vYear  },

    { el:'Î‘Î¯ÏƒÎ¸Î·ÏƒÎ· ÏˆÏÏ‡Î¿Ï…Ï‚',     en:'Wind Chill',   v: vChill },
    { el:'Î”ÎµÎ¯ÎºÏ„Î·Ï‚ Î´Ï…ÏƒÏ†Î¿ÏÎ¯Î±Ï‚',  en:'Heat Index',   v: vHeat  },
  ];
}


function setLatestValuesDisplay(lat, lineText){
  // hidden/plain text (for copy/debug)
  if(lineText != null) setTxt('stationLatestValues', lineText);
  else if(lat) setTxt('stationLatestValues', buildLatestLine(lat) || 'â€”');
  else setTxt('stationLatestValues', 'â€”');

  const wrap = document.getElementById('stationLatestChips');
  if(!wrap) return;

  const items = makeLatestChipItems(lat);
  wrap.style.setProperty('--chip-count', String(items.length || 0));

  wrap.innerHTML = '';
  if(!items.length){
    wrap.textContent = 'â€”';
    return;
  }

  for(const it of items){
    const chip = document.createElement('div');
    chip.className = 'chip' + (it.v === 'â€”' ? ' empty' : '');

    const el = document.createElement('div');
    el.className = 'el';
    el.textContent = it.el;

    const en = document.createElement('div');
    en.className = 'en';
    en.textContent = it.en;

    const v = document.createElement('div');
    v.className = 'val';
    v.textContent = it.v;

    chip.appendChild(el);
    chip.appendChild(en);
    chip.appendChild(v);
    wrap.appendChild(chip);
  }
}


function parseMeteoPageMinimal(text){
  const out = { rr: null, timestamp: null, timestampIsUTC: false, totals: null, latest: null, latestLine: null };

  // 1) Prefer the visible timestamp near "Latest Values / Î¤ÎµÎ»ÎµÏ…Ï„Î±Î¯ÎµÏ‚ Î¤Î¹Î¼Î­Ï‚" (LOCAL time)
  let mTs = text.match(/(?:Latest Values|Î¤ÎµÎ»ÎµÏ…Ï„Î±Î¯ÎµÏ‚\s*Î¤Î¹Î¼Î­Ï‚)[\s\S]{0,160}?(\d{1,2}\/\d{1,2}\/\d{4})\s+(\d{1,2}:\d{2})(?::(\d{2}))?/i);
  if(mTs){
    out.timestamp = `${mTs[1]}, ${mTs[2]}:${mTs[3] || '00'}`;
    out.timestampIsUTC = false;
  }

  // 2) "Timestamp:" style (often present in page source; ISO-like is typically UTC)
  if(!out.timestamp){
    const ts1 = text.match(/Timestamp\s*:?\s*([^\n<]{8,80})/i);
    if(ts1){
      out.timestamp = ts1[1].trim();
      out.timestampIsUTC = /\d{4}-\d{2}-\d{2}/.test(out.timestamp);
    }
  }

  // 3) ISO-like fallback anywhere (treat as UTC)
  if(!out.timestamp){
    const ts2 = text.match(/(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}(?::\d{2})?)/);
    if(ts2){
      out.timestamp = ts2[1].trim();
      out.timestampIsUTC = true;
    }
  }

  // rain rate (mm/h)
  let m = text.match(/Î’ÏÎ¿Ï‡[^\n]{0,40}?([0-9]+(?:\.[0-9]+)?)\s*mm\/h/i);
  if(!m) m = text.match(/([0-9]+(?:\.[0-9]+)?)\s*mm\/h/i);
  if(m) out.rr = Number(m[1]);

  // totals (today/storm) â€” supports Penteli/NOA pages like Chalandri:
  // "Today's Rain / Î£Î·Î¼ÎµÏÎ¹Î½ÏŒÏ‚ Î¥ÎµÏ„ÏŒÏ‚" and "Storm Total / Î¤ÏÎ­Ï‡Î¿Ï…ÏƒÎ± ÎºÎ±ÎºÎ¿ÎºÎ±Î¹ÏÎ¯Î±"
  let today = null, storm = null;

  const mtoday1 = text.match(/Î£ÏÎ½Î¿Î»Î¿\s*Î—Î¼Î­ÏÎ±Ï‚[\s\S]{0,80}?([0-9]+(?:\.[0-9]+)?)\s*mm/i);
  const mtoday2 = text.match(/(?:Today's\s*Rain|Î£Î·Î¼ÎµÏÎ¹Î½ÏŒÏ‚\s*Î¥ÎµÏ„ÏŒÏ‚)[\s\S]{0,80}?([0-9]+(?:\.[0-9]+)?)\s*mm/i);
  if(mtoday1) today = Number(mtoday1[1]);
  else if(mtoday2) today = Number(mtoday2[1]);

  const mstorm1 = text.match(/Î£ÏÎ½Î¿Î»Î¿\s*ÎšÎ±Ï„Î±Î¹Î³Î¯Î´Î±Ï‚[\s\S]{0,80}?([0-9]+(?:\.[0-9]+)?)\s*mm/i);
  const mstorm2 = text.match(/(?:Storm\s*Total|Î¤ÏÎ­Ï‡Î¿Ï…ÏƒÎ±\s*ÎºÎ±ÎºÎ¿ÎºÎ±Î¹ÏÎ¯Î±)[\s\S]{0,80}?([0-9]+(?:\.[0-9]+)?)\s*mm/i);
  if(mstorm1) storm = Number(mstorm1[1]);
  else if(mstorm2) storm = Number(mstorm2[1]);

  let total = null, totalSrc = null;
  if(storm != null){ total = storm; totalSrc = 'storm'; }
  else if(today != null){ total = today; totalSrc = 'today'; }

  if(total != null) out.totals = { today, storm, total, totalSrc };


    // ---------- Latest Values (full line) ----------
    const latest = {};
    latest.temp = pickNumFromText(text, /(?:Temperature|Î˜ÎµÏÎ¼Î¿ÎºÏÎ±ÏƒÎ¯Î±)[\s\S]{0,80}?(-?\d+(?:\.\d+)?)\s*Â°\s*C/i);
    latest.hum  = pickNumFromText(text, /(?:Humidity|Î¥Î³ÏÎ±ÏƒÎ¯Î±)[\s\S]{0,80}?(\d+(?:\.\d+)?)\s*%/i);
    latest.dew  = pickNumFromText(text, /(?:Dew\s*Point|Î£Î·Î¼ÎµÎ¯Î¿\s*Î”ÏÏŒÏƒÎ¿Ï…)[\s\S]{0,80}?(-?\d+(?:\.\d+)?)\s*Â°\s*C/i);

    // Wind: "4.8 Km/h at W"
    const windSpeed = pickNumFromText(text, /(?:Wind|Î†Î½ÎµÎ¼Î¿Ï‚)[\s\S]{0,120}?(\d+(?:\.\d+)?)\s*(?:Km\/h|km\/h)/i);
    const windDir   = pickMatchFromText(text, /(?:Wind|Î†Î½ÎµÎ¼Î¿Ï‚)[\s\S]{0,140}?\d+(?:\.\d+)?\s*(?:Km\/h|km\/h)\s*(?:at\s*)?([A-Za-z]{1,3})/i);
    if(windSpeed!=null){
      latest.wind = `${Number(windSpeed).toFixed(1)} km/h${windDir ? (' ' + windDir.toUpperCase()) : ''}`;
    }

    latest.baro = pickNumFromText(text, /(?:Barometer|Î’Î±ÏÏŒÎ¼ÎµÏ„ÏÎ¿)[\s\S]{0,80}?(\d+(?:\.\d+)?)\s*hPa/i);

    // Rain fields
    latest.today = (today!=null ? today : null);
    latest.storm = (storm!=null ? storm : null);
    latest.rr    = (out.rr!=null ? out.rr : null);
    latest.month = pickNumFromText(text, /(?:Monthly\s*Rain|ÎœÎ·Î½Î¹Î±Î¯Î¿Ï‚\s*Î¥ÎµÏ„ÏŒÏ‚)[\s\S]{0,80}?(\d+(?:\.\d+)?)\s*mm/i);
    latest.year  = pickNumFromText(text, /(?:Yearly\s*Rain|Î•Ï„Î®ÏƒÎ¹Î¿Ï‚\s*Î¥ÎµÏ„ÏŒÏ‚)[\s\S]{0,80}?(\d+(?:\.\d+)?)\s*mm/i);

    // Derived indices
    latest.chill = pickNumFromText(text, /(?:Wind\s*Chill|Î‘Î¯ÏƒÎ¸Î·ÏƒÎ·\s*ÏˆÏÏ‡Î¿Ï…Ï‚)[\s\S]{0,80}?(-?\d+(?:\.\d+)?)\s*Â°\s*C/i);
    latest.heat  = pickNumFromText(text, /(?:Heat\s*Index|Î”ÎµÎ¯ÎºÏ„Î·Ï‚\s*Î´Ï…ÏƒÏ†Î¿ÏÎ¯Î±Ï‚)[\s\S]{0,80}?(-?\d+(?:\.\d+)?)\s*Â°\s*C/i);

    // Sunrise / Sunset
    latest.sunrise = pickMatchFromText(text, /(?:Sunrise|Î‘Î½Î±Ï„Î¿Î»Î®)[\s\S]{0,80}?(\d{1,2}:\d{2})/i);
    latest.sunset  = pickMatchFromText(text, /(?:Sunset|Î”ÏÏƒÎ·)[\s\S]{0,80}?(\d{1,2}:\d{2})/i);

    out.latest = latest;
    out.latestLine = buildLatestLine(latest);

  return out;
}

function parseMeteoPage(text){
  // very lightweight heuristic (may vary by station page)
  // Try to find a mm/h value near "Rain Rate" or "mm/h"
  const rx = /([0-9]+(?:\.[0-9]+)?)\s*mm\/h/i;
  const m = text.match(rx);
  const rainRate = m ? parseFloat(m[1]) : null;

  // Try to find a timestamp-like pattern
  const tx = /(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2})/;
  const t = text.match(tx);
  const timestamp = t ? t[1] : null;

  return { rainRate, timestamp };
}

function updateStationMonitor(rainRate, tsText, totals){
  setTxt('stationTimestamp', tsText ? ts24(tsText) : 'â€”');
  setTxt('stationRainRate', (rainRate!=null && isFiniteNumber(rainRate)) ? rainRate.toFixed(1) : 'â€”');

  // dp/r60 derived from series
  if(totals && totals.total!=null){
    setTxt('stationTotalSrc', totals.totalSrc === 'storm' ? '(Storm)' : (totals.totalSrc === 'today' ? '(Î£Î®Î¼ÎµÏÎ±)' : ''));
  } else {
    setTxt('stationTotalSrc','');
  }
  updateStationReadouts();
}

function storeSampleForKey(seriesKey, sampleKey, tsText, val, label, totals, updateUI){
  const key = seriesKey || 'open-meteo';
  if(!sampleKey) return;

  const lastKey = stationLastKeyByKey[key] || null;
  if(sampleKey === lastKey) return;

  const series = stationSeriesByKey[key] || [];
  const prev = series.length ? series[series.length-1] : null;

  let dp = null;
  if(totals && totals.total!=null && prev && prev.total!=null && prev.totalSrc && prev.totalSrc === totals.totalSrc){
    dp = totals.total - prev.total;
    if(dp < 0) dp = totals.total;
  }

  const dParsed = parseAnyDateTime(tsText) || new Date();
  const dateMs = dParsed.getTime();

  series.push({
    key: sampleKey,
    tsText: tsText || sampleKey,
    val,
    label,
    total: totals ? totals.total : null,
    totalSrc: totals ? totals.totalSrc : null,
    dp,
    dateMs
  });

  if(series.length > STATION_SERIES_MAX){
    series.splice(0, series.length - STATION_SERIES_MAX);
  }

  stationSeriesByKey[key] = series;
  stationLastKeyByKey[key] = sampleKey;

  // keep globals in sync if this is the active context
  if(key === currentStationKey){
    stationSeries = series;
    stationLastKey = sampleKey;
    if(updateUI !== false) updateStationReadouts();
  }
}

function onNewStationSample(sampleKey, tsText, val, label, totals){
  storeSampleForKey(currentStationKey, sampleKey, tsText, val, label, totals, true);
}

function updateStationReadouts(){
  const latest = stationSeries.length ? stationSeries[stationSeries.length-1] : null;

  // dp = last dp if available
  const dp = latest?.dp;
  setTxt('stationDP', (dp!=null && isFiniteNumber(dp)) ? dp.toFixed(1) : 'â€”');

  // R60: sum dp over last 60 minutes if dp exists
  if(stationSeries.length && stationSeries.some(s=>s.dp!=null)){
    const now = stationSeries[stationSeries.length-1].dateMs;
    const cutoff = now - 60*60*1000;
    const sum = stationSeries.filter(s=>s.dateMs>=cutoff && s.dp!=null).reduce((a,b)=>a+b.dp,0);
    setTxt('stationR60', isFiniteNumber(sum) ? sum.toFixed(1) : 'â€”');
  } else {
    setTxt('stationR60', 'â€”');
  }
  renderStationSeriesList();
}

function renderStationSeriesList(){
  const box = document.getElementById('stationSeriesList');
  if(!box) return;
  if(!stationSeries || !stationSeries.length){
    box.innerHTML = 'â€”';
    return;
  }
  // show newest first
  const rows = stationSeries.slice().reverse().map(s=>{
    const ts = escapeHtml(ts24(s.tsText || 'â€”'));
    const val = (s.val!=null && isFiniteNumber(s.val)) ? `${s.val.toFixed(1)} mm/h` : 'â€”';
    const dp = (s.dp!=null && isFiniteNumber(s.dp)) ? `Î”P ${s.dp.toFixed(1)} mm` : '';
    return `<div class="series-row">
      <div class="series-ts">${ts}</div>
      <div class="series-val">${val}</div>
      <div class="series-dp">${dp}</div>
    </div>`;
  }).join('');
  box.innerHTML = rows;
}



/* ===================== STATION BUTTONS UI ===================== */
function updateStationButtons(){
  const autoBtn = document.getElementById('btnAutoStation');
  const liveBtn = document.getElementById('btnLiveStation');

  if(autoBtn){
    // Auto stays blue; Live is independent
    autoBtn.classList.add('btn-auto-default');
    autoBtn.classList.remove('btn-auto-live');
  }
  if(liveBtn){
    liveBtn.classList.toggle('btn-live-on', stationLiveOn);
    liveBtn.classList.toggle('btn-live-off', !stationLiveOn);
  }
}

function flashTempGreen(btnOrId, ms=3000){
  const btn = (typeof btnOrId === 'string') ? document.getElementById(btnOrId) : btnOrId;
  if(!btn) return;
  btn.classList.add('temp-green');
  setTimeout(()=> btn.classList.remove('temp-green'), ms);
}


function applyAutoI(){
  // Use latest station rain rate if exists
  const latest = stationSeries.length ? stationSeries[stationSeries.length-1] : null;
  if(latest && latest.val!=null){
    setVal('rainI', latest.val.toFixed(1));
    setStationMsg("Load: i ÎµÎ½Î·Î¼ÎµÏÏÎ¸Î·ÎºÎµ Î±Ï€ÏŒ ÏƒÏ„Î±Î¸Î¼ÏŒ.");
    flashTempGreen('btnAutoStation', 3000);
    runMasterCalculation();
  } else if(lastStationPayload){
    const rr = extractRainRate(lastStationPayload);
    if(rr!=null){
      setVal('rainI', rr.toFixed(1));
      setStationMsg("Load: i ÎµÎ½Î·Î¼ÎµÏÏÎ¸Î·ÎºÎµ Î±Ï€ÏŒ payload.");
      flashTempGreen('btnAutoStation', 3000);
      runMasterCalculation();
    } else {
      setStationMsg("Load: Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï„Î¹Î¼Î® Î²ÏÎ¿Ï‡Î®Ï‚.");
    }
  } else {
    setStationMsg("Load: Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï„Î¹Î¼Î® Î²ÏÎ¿Ï‡Î®Ï‚.");
  }
}

function toggleLive(){
  stationLiveOn = !stationLiveOn;
  updateStationButtons();

  const doFetch = ()=> {
    // prefer API fetch if ACTIVE primary OR watchlist monitoring
    const url = getPrimaryStationUrl();
    if(url || watchlist.size) fetchStationData();
    else fetchLiveMeteo();
  };

  if(stationLiveOn){
    setStationMsg("Live: ON (Î±Î½Î¬ 90s)");
    // Î¬Î¼ÎµÏƒÎ· Ï€ÏÏÏ„Î· Î»Î®ÏˆÎ· Î³Î¹Î± Î½Î± Î´ÎµÎ¹Ï‚ Î±Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î± Ï‡Ï‰ÏÎ¯Ï‚ Î½Î± Ï€ÎµÏÎ¹Î¼Î­Î½ÎµÎ¹Ï‚ 90s
    doFetch();
    if(stationLiveTimer) clearInterval(stationLiveTimer);
    stationLiveTimer = setInterval(doFetch, 90000);
  } else {
    setStationMsg("Live: OFF");
    if(stationLiveTimer) clearInterval(stationLiveTimer);
    stationLiveTimer = null;
  }
}

function clearStationSeries(){
  const ok = confirm("ÎÎ± Î³Î¯Î½ÎµÎ¹ ÎºÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Ï„Î·Ï‚ Ï‡ÏÎ¿Î½Î¿ÏƒÎµÎ¹ÏÎ¬Ï‚ Ï„Î¿Ï… ÏƒÏ„Î±Î¸Î¼Î¿Ï;");
  if(!ok) return;

  stationSeries = [];
  stationLastKey = null;

  // update store for current station context
  stationSeriesByKey[currentStationKey] = stationSeries;
  stationLastKeyByKey[currentStationKey] = stationLastKey;

  setTxt('stationDP','â€”');
  setTxt('stationR60','â€”');
  setStationMsg("Series ÎºÎ±Î¸Î±ÏÎ¯ÏƒÏ„Î·ÎºÎµ.");

  // Î¿Ï€Ï„Î¹ÎºÎ® ÎµÏ€Î¹Î²ÎµÎ²Î±Î¯Ï‰ÏƒÎ·: Ï€ÏÎ¬ÏƒÎ¹Î½Î¿ Î³Î¹Î± 3s ÎºÎ±Î¹ Î¼ÎµÏ„Î¬ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î®
  flashTempGreen('btnClearStation', 3000);
}

/* ===================== CALCULATIONS (ver14-style) ===================== */
function calculateTc(L, H){
  return (!L || !H) ? 10 : 0.0195 * Math.pow(L, 0.77) * Math.pow((H/L), -0.385);
}

function runMasterCalculation(){
  const area   = getVal('area');
  const length = getVal('length');
  const height = getVal('height');
  const coef   = getVal('coef');

  const rainI  = getVal('rainI');
  const rainD  = getVal('rainD');

  const drains   = getVal('drains');
  const drainCap = getVal('drainCap');

  const strWidth = getVal('strWidth');
  const strZ     = getVal('strZ');
  const strDepth = getVal('strDepth');
  const strDrop  = getVal('strDrop');
  const strLen   = getVal('strLen');
  const strType  = getVal('strType');
  const strYEl   = document.getElementById('strY');

  if(!(area>0)){
    // still draw empty
    setTxt('res-slope','â€”');
    setTxt('res-tc','â€”');
    setTxt('res-qsel','â€”');
    setTxt('res-drains','â€”');
    setTxt('res-stream','â€”');
    setTxt('res-adequacy','â€”');
    document.getElementById('tableBody').innerHTML='';
    drawChannel(0);
    drawBasinPlan();
    return;
  }

  const A_km2 = area / 1e6;
  const S = (length>0 && height>0) ? (height/length) : 0.01;

  const Tc = calculateTc(length, height);
  const Dused = (rainD > 0) ? rainD : Math.max(5.0, Tc);

  const Qsel = 0.278 * coef * rainI * A_km2;

  const CapNet = drains * drainCap;

  // Stream slope
  const sLen = (strLen>0) ? strLen : (length>0 ? length : 0);
  const sDrop = (strDrop>0) ? strDrop : (height>0 ? height : 0);
  const sSlope = (sLen>0) ? (sDrop/sLen) : 0;

  // Manning trapezoid capacity + normal depth by bisection
  let CapStr = 0;
  let yCalc = 0;

  const calcQ = (d) => {
    if(!(strWidth>0) || !(sSlope>0) || !(strType>0) || d<=0) return 0;
    const A = (strWidth + strZ*d) * d;
    const P = strWidth + 2*d*Math.sqrt(1 + Math.pow(strZ,2));
    return (1/strType) * Math.pow(A, 5/3) * Math.pow(P, -2/3) * Math.sqrt(sSlope);
  };

  if(strWidth>0 && strDepth>0 && sSlope>0){
    CapStr = calcQ(strDepth);

    if(Qsel>0){
      let low=0, high=(strDepth*2)||20;
      for(let i=0;i<22;i++){
        const mid=(low+high)/2;
        if(calcQ(mid) < Qsel) low=mid;
        else high=mid;
      }
      yCalc = (low+high)/2;
    }
  }

  // Manual y logic: if user types, treat as manual until resetStrY()
  if(strYEl && strYEl.dataset.boundManual !== '1'){
    strYEl.dataset.boundManual = '1';
    strYEl.addEventListener('input', ()=>{ strYEl.dataset.manual='true'; if(typeof scheduleSaveUiState==='function') scheduleSaveUiState(); });
  }
  const isManual = strYEl?.dataset?.manual === 'true';
  const yMan = isManual ? num(strYEl.value) : 0;
  const finalY = isManual ? yMan : yCalc;

  // update y field if auto
  if(!isManual && document.activeElement !== strYEl){
    strYEl.value = (yCalc>0) ? yCalc.toFixed(2) : "";
  }

  // Stats
  setTxt('res-slope', (S*100).toFixed(1) + " %");

  // Tc display with min rule (like ver14 dual)
  const tcEl = document.getElementById('res-tc');
  if((!rainD || rainD<=0) && Tc < 5){
    tcEl.innerHTML = `<span style="color:#d35400;font-weight:900">5.0 min</span>
                      <div style="font-size:10px;color:#6b7a86">(calc: ${Tc.toFixed(2)})</div>`;
  }else{
    tcEl.textContent = Tc.toFixed(1) + " min";
  }

  setTxt('res-qsel', Qsel.toFixed(2) + " mÂ³/s");
  setTxt('res-drains', (CapNet>0 ? CapNet.toFixed(2) : "0.00") + " mÂ³/s");
  setTxt('res-stream', (CapStr>0 ? CapStr.toFixed(2) : "0.00") + " mÂ³/s");

  // adequacy label
  let adq = "<span style='color:#6b7a86'>â€”</span>";
  if(CapNet>0 && CapStr>0) adq = "<span class='status-ok'>Î”Î¹Ï€Î»ÏŒÏ‚ Î­Î»ÎµÎ³Ï‡Î¿Ï‚</span>";
  else if(CapNet>0) adq = "<span class='status-fail'>ÎœÏŒÎ½Î¿ ÏƒÏ…Î»Î»Î¿Î³Î®</span>";
  else if(CapStr>0) adq = "<span class='status-fail'>ÎœÏŒÎ½Î¿ Î´Î¹ÏŒÎ´ÎµÏ…ÏƒÎ·</span>";
  else adq = "<span class='status-warn'>Î§Ï‰ÏÎ¯Ï‚ Qcap</span>";
  document.getElementById('res-adequacy').innerHTML = adq;

  // Scenario table
  const tbody = document.getElementById('tableBody');
  tbody.innerHTML = "";

  const status = (Q, Cap) => {
    if(!(Cap>0)) return "<span class='status-fail' style='font-size:11px'>â€”</span>";
    if(Q <= Cap*0.85) return "<span class='status-ok'>OK</span>";
    if(Q <= Cap) return "<span class='status-warn'>ÎŸÏÎ¹Î±ÎºÏŒ</span>";
    return "<span class='status-fail'>Î¥Ï€Î­ÏÎ²Î±ÏƒÎ·</span>";
  };

  for(let i=5;i<=200;i+=5){
    const P = i*(Dused/60);
    const Q = 0.278*coef*i*A_km2;
    const V = area*(P/1000)*coef;
    const Peq = P*coef;

    let cls="risk-safe", txt="Î§Î±Î¼Î·Î»Î®";
    if(Peq>=60){cls="risk-extreme";txt="Î‘ÎºÏÎ±Î¯Î±";}
    else if(Peq>=40){cls="risk-red";txt="Î Î¿Î»Ï Î¥ÏˆÎ·Î»Î®";}
    else if(Peq>=25){cls="risk-orange";txt="Î¥ÏˆÎ·Î»Î®";}
    else if(Peq>=10){cls="risk-warn";txt="ÎœÎ­Ï„ÏÎ¹Î±";}

    const tr = document.createElement('tr');
    tr.className = cls;
    tr.innerHTML = `
      <td><b>${i}</b></td>
      <td>${Dused.toFixed(1)}</td>
      <td>${P.toFixed(1)}</td>
      <td>${Q.toFixed(2)}</td>
      <td>${Math.round(V).toLocaleString('el-GR')}</td>
      <td>${txt}<br><span style="font-size:11px;color:#6b7a86">Peq=${Peq.toFixed(1)}</span></td>
      <td>${status(Q, CapNet)}</td>
      <td>${status(Q, CapStr)}</td>
    `;
    tbody.appendChild(tr);
  }

  drawChannel(finalY);
  drawBasinPlan();

  if(typeof scheduleSaveUiState==='function') scheduleSaveUiState();
}


function resetStrY(){
  const el = document.getElementById('strY');
  if(!el) return;
  el.value = "";
  delete el.dataset.manual;
  runMasterCalculation();
}

/* ===================== VISUALIZERS ===================== */
function drawBasinPlan(){
  const canvas = document.getElementById('basinCanvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  // background
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,w,h);

  // If we have GeoJSON rings, draw them; else schematic
  const gj = SELECTED_GEO;
  const rings = gj ? geojsonToRings(gj) : [];
  const style = basinStyleFromInputs();

  if(rings && rings.length && drawGeoRings(ctx, rings, w, h, style)){
    // label
    ctx.fillStyle = "#2c3e50";
    ctx.font = "bold 10px Arial";
    ctx.fillText("Î ÎµÏÎ¯Î³ÏÎ±Î¼Î¼Î± (GeoJSON)", 8, 14);
    drawBasinLegend(ctx, style);
    return;
  }

  // schematic fallback based on A & L
  const A = getVal('area'), L = getVal('length');
  if(!(A>0) || !(L>0)){
    ctx.fillStyle="#9aa6b2";
    ctx.font="12px Arial";
    ctx.textAlign="center";
    ctx.fillText("ÎŸÏÎ¯ÏƒÏ„Îµ A & L Î® Ï†Î¿ÏÏ„ÏÏƒÏ„Îµ Î»ÎµÎºÎ¬Î½Î·", w/2, h/2);
    drawBasinLegend(ctx, style);
    return;
  }
  const W = A / L;
  const pad=14;
  const maxW=w-2*pad, maxH=h-2*pad;
  const scale = Math.min(maxW/(L||1), maxH/((W||1)));
  const Ls=L*scale, Ws=(W||1)*scale;
  const x=(w-Ls)/2, y=(h-Ws)/2;

  roundRect(ctx, x,y,Ls,Ws, Math.min(12, Ws/2, Ls/8));
  ctx.fillStyle = style.fill;
  ctx.fill();
  ctx.strokeStyle = style.stroke;
  ctx.lineWidth = style.lineWidth;
  ctx.stroke();

  ctx.fillStyle="#2c3e50";
  ctx.font="bold 10px Arial";
  ctx.textAlign="center";
  ctx.fillText(`Lâ‰ˆ${Math.round(L)} m`, w/2, h-6);

  ctx.save();
  ctx.translate(10, h/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign="center";
  ctx.fillText(`Wâ‰ˆ${Math.round(W)} m`, 0, 0);
  ctx.restore();

  drawBasinLegend(ctx, style);
}

function basinStyleFromInputs(){
  const Qpeak = 0.278 * getVal('coef') * getVal('rainI') * (getVal('area')/1e6);
  const CapNet = getVal('drains') * getVal('drainCap');
  const CapStr = estimateStreamCap();
  // simple coloring: fill by Peq class, stroke by capacity stress
  const Dused = (getVal('rainD')>0) ? getVal('rainD') : Math.max(5, calculateTc(getVal('length'), getVal('height')));
  const P = getVal('rainI')*(Dused/60);
  const Peq = P*getVal('coef');

  let fill="#eafaf1";
  if(Peq>=60) fill="#ffd1d1";
  else if(Peq>=40) fill="#ffe0e0";
  else if(Peq>=25) fill="#ffe9d6";
  else if(Peq>=10) fill="#fff7e6";

  let stroke="#2c3e50";
  let lw=2;
  const netBad = (CapNet>0 && Qpeak>CapNet);
  const strBad = (CapStr>0 && Qpeak>CapStr);
  if(netBad || strBad){ stroke="#c0392b"; lw=3; }
  else if((CapNet>0 && Qpeak>CapNet*0.85) || (CapStr>0 && Qpeak>CapStr*0.85)){ stroke="#d35400"; lw=3; }

  return { fill, stroke, lineWidth: lw };
}

function estimateStreamCap(){
  const strWidth = getVal('strWidth');
  const strZ = getVal('strZ');
  const strDepth = getVal('strDepth');
  const strDrop = getVal('strDrop');
  const strLen = getVal('strLen');
  const strType = getVal('strType');
  const length = getVal('length');
  const height = getVal('height');

  const sLen = (strLen>0)? strLen : length;
  const sDrop = (strDrop>0)? strDrop : height;
  const sSlope = (sLen>0)? (sDrop/sLen) : 0;
  if(!(strWidth>0) || !(strDepth>0) || !(sSlope>0) || !(strType>0)) return 0;
  const A = (strWidth + strZ*strDepth)*strDepth;
  const P = strWidth + 2*strDepth*Math.sqrt(1+strZ*strZ);
  return (1/strType) * Math.pow(A, 5/3) * Math.pow(P, -2/3) * Math.sqrt(sSlope);
}

function drawBasinLegend(ctx, style){
  const x=8, y=ctx.canvas.height-16;
  ctx.fillStyle="#2c3e50";
  ctx.font="bold 10px Arial";
  ctx.textAlign="left";
  ctx.fillText("Fill=Peq, Stroke=Qcap stress", x, y);
  // swatches
  ctx.fillStyle = style.fill;
  ctx.fillRect(ctx.canvas.width-58, ctx.canvas.height-22, 18, 12);
  ctx.strokeStyle = style.stroke;
  ctx.lineWidth = style.lineWidth;
  ctx.strokeRect(ctx.canvas.width-30, ctx.canvas.height-22, 18, 12);
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

function geojsonToRings(gj){
  const rings = [];
  try{
    const feat = gj.features ? gj.features[0] : gj;
    const g = feat.geometry || feat;
    if(!g) return rings;

    const pushPoly = (poly) => {
      // poly: [ [ [lon,lat], ... ] , holes... ]
      if(Array.isArray(poly) && poly.length){
        rings.push(poly[0]);
      }
    };

    if(g.type === 'Polygon') pushPoly(g.coordinates);
    if(g.type === 'MultiPolygon'){
      for(const poly of g.coordinates) pushPoly(poly);
    }
  }catch(_){}
  return rings;
}

function drawGeoRings(ctx, rings, w, h, style){
  try{
    // safety limits (avoid UI freeze on huge/corrupted GeoJSON)
    const MAX_RINGS = 120;
    const MAX_POINTS = 15000;

    if(!Array.isArray(rings)) return false;
    if(rings.length > MAX_RINGS) rings = rings.slice(0, MAX_RINGS);

    let totalPoints = 0;
    rings = rings.map(r=>{
      if(!Array.isArray(r)) return null;
      const remain = MAX_POINTS - totalPoints;
      if(remain <= 0) return null;
      const take = Math.min(r.length, remain);
      totalPoints += take;
      return r.slice(0, take);
    }).filter(r=>r && r.length >= 3);

    if(!rings.length) return false;

    // find bounds
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const r of rings){
      for(const [x,y] of r){
        if(x<minX) minX=x;
        if(y<minY) minY=y;
        if(x>maxX) maxX=x;
        if(y>maxY) maxY=y;
      }
    }
    if(!isFinite(minX) || !isFinite(maxX)) return false;

    const pad=14;
    const sx=(w-2*pad)/((maxX-minX)||1);
    const sy=(h-2*pad)/((maxY-minY)||1);
    const s=Math.min(sx,sy);

    const tx = (x)=> pad + (x-minX)*s;
    const ty = (y)=> h-pad - (y-minY)*s; // flip

    ctx.beginPath();
    for(const r of rings){
      for(let i=0;i<r.length;i++){
        const p = r[i];
        const X = tx(p[0]);
        const Y = ty(p[1]);
        if(i===0) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      }
      ctx.closePath();
    }
    ctx.fillStyle = style.fill;
    ctx.fill();
    ctx.strokeStyle = style.stroke;
    ctx.lineWidth = style.lineWidth;
    ctx.stroke();
    return true;
  }catch(e){
    return false;
  }
}

function drawChannel(y_real){
  const canvas = document.getElementById('channelCanvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);

  const b = getVal('strWidth');
  const z = getVal('strZ');
  const H = getVal('strDepth');
  const y = y_real;

  if(b<=0 && H<=0){
    ctx.fillStyle="#9aa6b2";
    ctx.font="12px Arial";
    ctx.textAlign="center";
    ctx.fillText("ÎŸÏÎ¯ÏƒÏ„Îµ b & h", w/2, h/2);
    return;
  }

  const maxH = Math.max(H, y);
  const topW = b + 2*(z*maxH);
  const pad=20;
  const scale = Math.min((w-pad)/(topW||1),(h-pad)/(maxH||1));
  const cx=w/2, cy=h-16;

  const gx = (wd)=>(wd*scale)/2;
  const gy = (d)=> cy - (d*scale);

  const drawPoly = (tw, d, fill, stroke, dash=[])=>{
    ctx.beginPath();
    ctx.moveTo(cx-gx(tw), gy(d));
    ctx.lineTo(cx-gx(b), cy);
    ctx.lineTo(cx+gx(b), cy);
    ctx.lineTo(cx+gx(tw), gy(d));
    ctx.closePath();
    if(fill){ ctx.fillStyle=fill; ctx.fill(); }
    if(stroke){
      ctx.strokeStyle=stroke;
      ctx.setLineDash(dash);
      ctx.lineWidth=2;
      ctx.stroke();
      ctx.setLineDash([]);
    }
  };

  // banks outline
  if(H>0){
    drawPoly(b+2*z*H, H, null, "#5D4037");
  }
  // water
  if(y>0){
    const isOver = (H>0 && y>H);
    drawPoly(b+2*z*Math.min(y, H*1.5||y), Math.min(y, H*1.5||y),
      isOver ? "rgba(231,76,60,0.55)" : "rgba(52,152,219,0.55)",
      isOver ? "#c0392b" : "#2980b9",
      []
    );
    // waterline
    ctx.beginPath();
    ctx.moveTo(cx-gx(b+2*z*y), gy(y));
    ctx.lineTo(cx+gx(b+2*z*y), gy(y));
    ctx.strokeStyle="#2c3e50";
    ctx.lineWidth=1;
    ctx.stroke();

    ctx.fillStyle="#2c3e50";
    ctx.font="bold 10px Arial";
    ctx.textAlign="center";
    ctx.fillText(`y=${y.toFixed(2)}m`, cx, gy(y)-6);
  }

  ctx.fillStyle="#2c3e50";
  ctx.font="bold 10px Arial";
  ctx.textAlign="center";
  if(b>0) ctx.fillText(`b=${b}m`, cx, cy+12);
}

/* ===================== Inputs binding ===================== */
function bindInputs(){
  const ids = [
    'rainI','rainD','area','length','height','coef',
    'drains','drainCap',
    'strWidth','strZ','strDepth','strDrop','strLen','strType','strY'
  ];

  // avoid heavy recalcs while typing
  const debouncedCalc = debounce(()=>{ runMasterCalculation(); scheduleSaveUiState(); }, 140);

  ids.forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;

    // bind once
    if(el.dataset.boundCalc === '1') return;
    el.dataset.boundCalc = '1';

    el.addEventListener('input', debouncedCalc);
    el.addEventListener('change', ()=>{ runMasterCalculation(); scheduleSaveUiState(); });
  });

  // Make strY manual once user edits it (bind once)
  const strYEl = document.getElementById('strY');
  if(strYEl && strYEl.dataset.boundManual !== '1'){
    strYEl.dataset.boundManual = '1';
    strYEl.addEventListener('input', ()=>{ strYEl.dataset.manual='true'; scheduleSaveUiState(); });
  }
}


</script>

<script>
/* ===================== BOOT ===================== */
init();
</script>

</body>
</html>
