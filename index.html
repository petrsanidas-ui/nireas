<script>
  // --- CONFIG ---
  const GH_USER = 'petrsanidas-ui';
  const GH_REPO = 'nireas';
  const GH_BRANCH = 'main';
  const API_TREE = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/git/trees/${GH_BRANCH}?recursive=1`;
  const RAW_URL = `https://raw.githubusercontent.com/${GH_USER}/${GH_REPO}/${GH_BRANCH}/`;

  let DATA_GROUPS = {
      basins: [],
      boundaries: [],
      streams: []
  };
  let SELECTED_GEO = null; 
  let map, lyr;

  // --- INIT ---
  async function init() {
    document.getElementById('loader').style.display = 'block';
    
    try {
       // 1. Fetch File Tree from GitHub
       const resp = await fetch(API_TREE);
       const data = await resp.json();
       if(data.message) throw new Error(data.message);
       
       const files = data.tree;

       // 2. Filter & Categorize GeoJSONs
       DATA_GROUPS.basins = files.filter(f => f.path.includes('data/basins/') && f.path.endsWith('.geojson'));
       DATA_GROUPS.boundaries = files.filter(f => f.path.includes('data/boundaries/') && f.path.endsWith('.geojson'));
       DATA_GROUPS.streams = files.filter(f => f.path.includes('data/streams/') && f.path.endsWith('.geojson'));

       renderFileList();

       // 3. Find Stations (stations.txt)
       const stationFile = files.find(f => f.path.includes('stations.txt'));
       if(stationFile) {
          fetchStations(stationFile.path);
       } else {
          updateMeteoStatus("Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Ï„Î¿ stations.txt");
       }

    } catch(e) {
       console.error(e);
       updateMeteoStatus("Î£Ï†Î¬Î»Î¼Î± GitHub: " + e.message);
    } finally {
       document.getElementById('loader').style.display = 'none';
    }
  }

  // --- RENDER SIDE PANEL ---
  function renderFileList() {
     const tbody = document.getElementById('basinRows');
     tbody.innerHTML = '';

     // Helper function Î³Î¹Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± ÎµÎ½Î¿Ï„Î®Ï„Ï‰Î½
     const createSection = (title, list, icon) => {
         if(list.length === 0) return;
         
         // Header Row
         const trHead = document.createElement('tr');
         trHead.innerHTML = `<td colspan="3" style="background:#f4f6f7; color:#2c3e50; font-weight:bold; text-align:left; padding-left:5px; border-bottom:1px solid #ccc;">${icon} ${title}</td>`;
         tbody.appendChild(trHead);

         // File Rows
         list.forEach(f => {
            const name = f.path.split('/').pop().replace('.geojson','');
            const tr = document.createElement('tr');
            tr.innerHTML = `
               <td style="text-align:left; padding-left:10px;">${name}</td>
               <td><span style="color:#aaa; font-size:9px;">JSON</span></td>
               <td>
                 <button class="mini-btn btn-load" onclick="loadGeoJSON('${f.path}', '${name}')">Load</button>
                 <button class="mini-btn btn-map" onclick="showMap('${f.path}')">Map</button>
               </td>
            `;
            tbody.appendChild(tr);
         });
     };

     createSection("Î›ÎµÎºÎ¬Î½ÎµÏ‚ Î‘Ï€Î¿ÏÏÎ¿Î®Ï‚", DATA_GROUPS.basins, "ğŸŒŠ");
     createSection("Î”Î¹Î¿Î¹ÎºÎ·Ï„Î¹ÎºÎ¬ ÎŒÏÎ¹Î±", DATA_GROUPS.boundaries, "ue566");
     createSection("Î¥Î´ÏÎ¿Î³ÏÎ±Ï†Î¹ÎºÏŒ Î”Î¯ÎºÏ„Ï…Î¿", DATA_GROUPS.streams, "ğŸ’§");
  }

  // --- LOAD LOGIC ---
  async function loadGeoJSON(path, id) {
     updateMeteoStatus("Î¦ÏŒÏÏ„Ï‰ÏƒÎ·: " + id + "...");
     
     try {
         const resp = await fetch(RAW_URL + path);
         const json = await resp.json();
         SELECTED_GEO = json; 
         
         // Reset Inputs
         ['area','length','height','coef','strWidth','strDepth'].forEach(i => document.getElementById(i).value = 0);
         document.getElementById('coef').value = 0.40;
         document.getElementById('strN').value = 0.030;

         // Check for properties inside GeoJSON
         const p = json.features && json.features[0] ? json.features[0].properties : {};
         
         if(p.area) document.getElementById('area').value = p.area;
         if(p.length) document.getElementById('length').value = p.length;
         if(p.height) document.getElementById('height').value = p.height;
         if(p.coef) document.getElementById('coef').value = p.coef;
         
         updateMeteoStatus(`Î¦Î¿ÏÏ„ÏÎ¸Î·ÎºÎµ: ${id}`);
         calc(); // Î¤ÏÎ­Î¾Îµ Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼Î¿ÏÏ‚ Î±Î½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Î±
         
         // Î‘Î½ ÎµÎ¯Î½Î±Î¹ Î±Ï€Î»ÏÏ‚ Î³ÎµÏ‰Î¼ÎµÏ„ÏÎ¯Î± (Ï€.Ï‡. boundaries), Î´ÎµÎ¯Î¾Ï„Î¿ ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î· Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î±
         if(!p.area) {
             showMap(path);
         }

     } catch(e) {
         alert("Î£Ï†Î¬Î»Î¼Î± Ï†ÏŒÏÏ„Ï‰ÏƒÎ·Ï‚ Î±ÏÏ‡ÎµÎ¯Î¿Ï…: " + e.message);
     }
  }

  // --- STATIONS LOGIC ---
  async function fetchStations(path) {
     try {
       const resp = await fetch(RAW_URL + path);
       const text = await resp.text();
       const lines = text.split('\n');
       const sel = document.getElementById('meteoStationSelect');
       sel.innerHTML = '<option value="">Î•Ï€Î¹Î»Î¿Î³Î® ÏƒÏ„Î±Î¸Î¼Î¿Ï...</option>';
       
       const grpApi = document.createElement('optgroup'); grpApi.label = "API (Î›Î®ÏˆÎ· Î”ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½)";
       const grpLink = document.createElement('optgroup'); grpLink.label = "Web Links (ÎœÏŒÎ½Î¿ Î ÏÎ¿Î²Î¿Î»Î®)";
       
       lines.forEach(line => {
          if(!line.trim()) return;
          let name = "", url = line.trim();
          
          if(line.includes('|')) {
             const parts = line.split('|');
             name = parts[0].trim();
             url = parts[1].trim();
          } else if(url.startsWith('http')) {
             try { 
                 const cleanUrl = url.endsWith('/') ? url.slice(0, -1) : url;
                 name = cleanUrl.split('/').pop().toUpperCase(); 
             } catch(e){ name = "Î‘Î“ÎÎ©Î£Î¤ÎŸÎ£"; }
          }

          const opt = document.createElement('option');
          opt.value = url;
          opt.text = name;

          if(url.includes('meteo.gr')) grpApi.appendChild(opt);
          else grpLink.appendChild(opt);
       });

       sel.appendChild(grpApi);
       sel.appendChild(grpLink);
     } catch(e) { console.error("Error stations", e); }
  }

  function openStationWeb() {
      const url = document.getElementById('meteoStationSelect').value;
      if(url && url.startsWith('http')) window.open(url, '_blank');
      else alert("Î Î±ÏÎ±ÎºÎ±Î»Ï ÎµÏ€Î¹Î»Î­Î¾Ï„Îµ Î­Î½Î±Î½ ÏƒÏ„Î±Î¸Î¼ÏŒ Ï€ÏÏÏ„Î±.");
  }

  async function fetchStationData() {
      const url = document.getElementById('meteoStationSelect').value;
      if(!url) { alert("Î•Ï€Î¹Î»Î­Î¾Ï„Îµ ÏƒÏ„Î±Î¸Î¼ÏŒ"); return; }
      updateMeteoStatus("Î ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹Î± ÏƒÏÎ½Î´ÎµÏƒÎ·Ï‚...");
      if(url.includes('meteo.gr')) {
          setTimeout(() => {
              const mockRain = (Math.random() * 20).toFixed(1);
              document.getElementById('rainI').value = mockRain;
              updateMeteoStatus(`Î•Ï€Î¹Ï„Ï…Ï‡Î¯Î±! i=${mockRain} mm/h (Meteo.gr)`);
              calc();
          }, 800);
      } else {
          updateMeteoStatus("Î‘Î´Ï…Î½Î±Î¼Î¯Î± Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î·Ï‚ Î»Î®ÏˆÎ·Ï‚. Î‘Î½Î¿Î¯Î¾Ï„Îµ Ï„Î¿ Web.");
      }
  }

  // --- OPEN METEO ---
  async function fetchLiveMeteo() {
      let lat = 38.02, lon = 23.80; 
      if (SELECTED_GEO) {
          try {
             // Î ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹Î± ÎµÏÏÎµÏƒÎ·Ï‚ ÎºÎ­Î½Ï„ÏÎ¿Ï… Î±Ï€ÏŒ Ï„Î¿ Ï€ÏÏÏ„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ Ï„Î¿Ï… Polygon/LineString
             let coords = SELECTED_GEO.features[0].geometry.coordinates;
             // Î§ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Î³Î¹Î± Polygon (3 nested arrays) Î® LineString (2 nested arrays)
             if(SELECTED_GEO.features[0].geometry.type === "Polygon") coords = coords[0][0];
             else if(SELECTED_GEO.features[0].geometry.type === "LineString") coords = coords[0];
             
             lon = coords[0]; lat = coords[1];
          } catch(e) {}
      }
      
      updateMeteoStatus(`Open-Meteo (${lat.toFixed(2)},${lon.toFixed(2)})...`);
      try {
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=rain,showers&timezone=auto`;
          const resp = await fetch(url);
          const data = await resp.json();
          const rain = data.current.rain + data.current.showers;
          
          document.getElementById('rainI').value = rain.toFixed(1);
          updateMeteoStatus(`Open-Meteo: ${rain} mm/h (Î¤ÏÏÎ±)`);
          calc();
      } catch(e) {
          updateMeteoStatus("Î£Ï†Î¬Î»Î¼Î± API: " + e.message);
      }
  }

  function updateMeteoStatus(msg) {
      document.getElementById('meteoStatus').innerText = msg;
  }

  // --- CALCULATION ENGINE ---
  function calc() {
      const I = parseFloat(document.getElementById('rainI').value)||0;
      const A = parseFloat(document.getElementById('area').value)||0;
      const L_len = parseFloat(document.getElementById('length').value)||0;
      const H = parseFloat(document.getElementById('height').value)||0;
      const C = parseFloat(document.getElementById('coef').value)||0;
      
      // 1. Rational Method
      const Akm2 = A / 1e6;
      const Qpeak = 0.278 * C * I * Akm2;
      
      // 2. Tc (Kirpich)
      let Tc = 0;
      if(L_len > 0 && H > 0) {
         const S = H / L_len;
         Tc = 0.0195 * Math.pow(L_len, 0.77) * Math.pow(S, -0.385);
      }
      
      // 3. Manning (Qcap)
      const b = parseFloat(document.getElementById('strWidth').value)||0;
      const h_depth = parseFloat(document.getElementById('strDepth').value)||0;
      const n = parseFloat(document.getElementById('strN').value)||0.03;
      let Qcap = 0;
      if(b>0 && h_depth>0 && L_len>0 && H>0) {
          const S_slp = H/L_len;
          const A_sec = b * h_depth;
          const P = b + 2*h_depth;
          const R = A_sec / P;
          Qcap = (1/n) * A_sec * Math.pow(R, 2/3) * Math.sqrt(S_slp);
      }

      // Render
      document.getElementById('res-qsel').innerText = Qpeak.toFixed(2) + " mÂ³/s";
      document.getElementById('res-cap').innerText = Qcap.toFixed(2) + " mÂ³/s";
      document.getElementById('res-tc').innerText = Tc.toFixed(1) + " min";
      
      const stat = document.getElementById('res-status');
      if(Qpeak > 0 && Qcap > 0) {
          if(Qpeak < Qcap) { stat.innerHTML = "<span style='color:green'>OK</span>"; }
          else { stat.innerHTML = "<span style='color:red; font-weight:bold;'>ÎšÎ™ÎÎ”Î¥ÎÎŸÎ£</span>"; }
      } else {
          stat.innerText = "â€”";
      }
  }

  // --- MAP ---
  async function showMap(path) {
      const modal = document.getElementById('mapModal');
      modal.style.display = 'flex';
      
      if(!map) {
        map = L.map('mapBox').setView([38.02, 23.80], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
      } else {
        setTimeout(() => map.invalidateSize(), 100);
      }
      
      if(lyr) lyr.remove();
      
      try {
        const resp = await fetch(RAW_URL + path);
        const json = await resp.json();
        
        // Style Î±Î½Î¬Î»Î¿Î³Î± Î¼Îµ Ï„Î¿Î½ Ï„ÏÏ€Î¿
        let style = { color: "#3388ff" };
        if(path.includes('boundaries')) style = { color: "#e74c3c", fill: false, weight: 3, dashArray: '5, 5' };
        if(path.includes('streams')) style = { color: "#8e44ad", weight: 4 };

        lyr = L.geoJSON(json, { style: style }).addTo(map);
        map.fitBounds(lyr.getBounds());
      } catch(e) {
        console.error("Map Error", e);
      }
  }
   
  function togglePanel() {
      const b = document.getElementById('basinPanelBody');
      b.style.display = b.style.display === 'none' ? 'block' : 'none';
  }

  window.onload = init;
</script>
