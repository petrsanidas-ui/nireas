<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ÎÎ—Î¡Î•Î‘Î£ â€” GitHub Data + Peq Screening Tool</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --bg:#eef2f5;
      --panel:#ffffff;
      --ink:#2c3e50;
      --muted:#6b7a86;
      --line:#d6dde4;
      --hdr:#2c3e50;

      --btn-blue:#2980b9;
      --btn-green:#27ae60;
      --btn-gray:#7f8c8d;

      --danger:#c0392b;
      --warn:#d35400;
      --ok:#27ae60;

      --shadow:0 10px 24px rgba(0,0,0,.12);
      --radius:10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:var(--bg);
      color:var(--ink);
    }

    /* ====== Layout (side-by-side, no overlap) ====== */
    .app-shell{
      display:flex;
      gap:14px;
      padding:14px;
      align-items:flex-start;
    }
    @media (max-width: 1100px){
      .app-shell{flex-direction:column}
    }

    .side-panel{
      width:390px;
      max-width:100%;
      background:var(--panel);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      border:1px solid rgba(0,0,0,.06);
    }
    .main-panel{
      flex:1;
      min-width:380px;
      background:var(--panel);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      border:1px solid rgba(0,0,0,.06);
    }

    /* ====== Panel headers & collapsibles ====== */
    .panel-topbar{
      background:var(--hdr);
      color:#fff;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      font-weight:700;
      font-size:14px;
    }
    .icon-btn{
      border:none;
      background:rgba(255,255,255,.14);
      color:#fff;
      width:30px;height:26px;
      border-radius:6px;
      cursor:pointer;
      font-weight:900;
      line-height:1;
    }
    .icon-btn:hover{background:rgba(255,255,255,.22)}
    .section{
      border-top:1px solid rgba(255,255,255,.08);
    }
    .section-hdr{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-top:1px solid var(--line);
      background:#f7f9fb;
      font-weight:800;
      color:var(--ink);
    }
    .section-body{
      padding:10px 12px;
    }
    .collapsed{display:none!important}

    /* ====== Buttons ====== */
    .mini-btn{
      border:none;
      border-radius:4px;
      padding:4px 8px;
      font-size:11px;
      cursor:pointer;
      color:#fff;
      font-weight:800;
      line-height:1.1;
      user-select:none;
    }
    .btn-load{background:var(--btn-blue)}
    .btn-map{background:var(--btn-green)}
    .btn-gray{background:var(--btn-gray)}
    .btn-on{background:var(--btn-green)}
    .btn-off{background:var(--btn-gray)}
    .mini-btn:hover{filter:brightness(.95)}
    .mini-btn:active{transform:translateY(1px)}

    /* ====== Side table ====== */
    table{border-collapse:collapse;width:100%}
    th,td{padding:6px;border-bottom:1px solid #e9eef3;text-align:center;font-size:12px}
    th{background:#34495e;color:#fff;font-size:12px}
    .cat-row td{
      background:#f3f6f8;
      font-weight:900;
      text-align:left;
      padding:7px 10px;
      border-bottom:1px solid #dfe7ee;
    }
    .type-cell{color:#9aa6b2;font-size:10px}

    .hint{
      font-size:10px;
      color:var(--muted);
      padding:10px 12px;
      border-top:1px solid var(--line);
    }

    /* ====== Main tool (ver14-like) ====== */
    .tool-wrap{padding:12px}
    .tool-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background:#fbfcfe;
    }
    .tool-header h1{
      margin:0;
      font-size:15px;
      letter-spacing:.2px;
    }
    .print-btn{
      border:none;
      background:#2c3e50;
      color:#fff;
      border-radius:6px;
      padding:7px 10px;
      font-size:12px;
      cursor:pointer;
      font-weight:800;
    }
    .print-btn:hover{filter:brightness(.95)}

    .sel-basin{
      margin:10px 0 0 0;
      font-size:12px;
      color:#2c3e50;
      font-weight:800;
    }
    .sel-basin span{
      font-weight:900;
      color:#d35400;
    }

    .grid-2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 900px){
      .grid-2{grid-template-columns:1fr}
    }

    .box{
      border:1px solid #dfe7ee;
      background:#fff;
      border-radius:10px;
      padding:10px;
    }
    .box h3{
      margin:0 0 8px 0;
      font-size:13px;
      font-weight:900;
    }
    .row{
      display:grid;
      grid-template-columns:1.2fr 1fr;
      gap:8px;
      align-items:center;
      margin:6px 0;
    }
    .row label{
      font-size:12px;
      color:#2c3e50;
      font-weight:800;
    }
    input,select{
      width:100%;
      font-size:12px;
      padding:6px 8px;
      border:1px solid #d6dde4;
      border-radius:6px;
      outline:none;
      background:#fff;
    }

    .panels-row{
      display:grid;
      grid-template-columns:1fr 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 1150px){
      .panels-row{grid-template-columns:1fr}
    }

    canvas{
      width:100%;
      border:1px dashed #cfd8e3;
      border-radius:8px;
      background:#fff;
    }

    .summary-box{
      display:grid;
      grid-template-columns:repeat(6, 1fr);
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 1150px){
      .summary-box{grid-template-columns:repeat(2,1fr)}
    }
    .stat{
      border:1px solid #e6edf3;
      background:#fbfdff;
      border-radius:10px;
      padding:8px;
      text-align:center;
    }
    .stat .k{font-size:11px;color:#6b7a86;font-weight:800}
    .stat .v{font-size:14px;font-weight:900;margin-top:4px}

    .status-ok{color:var(--ok);font-weight:900}
    .status-warn{color:var(--warn);font-weight:900}
    .status-fail{color:var(--danger);font-weight:900}

    /* Scenario table + risk colors */
    .table-wrap{
      margin-top:12px;
      border:1px solid #e6edf3;
      border-radius:10px;
      overflow:hidden;
    }
    .table-wrap table{width:100%}
    .table-wrap th{background:#34495e}
    .risk-safe{background:#eafaf1}
    .risk-warn{background:#fff7e6}
    .risk-orange{background:#ffe9d6}
    .risk-red{background:#ffe0e0}
    .risk-extreme{background:#ffd1d1}

    .footer-grid{
      display:grid;
      grid-template-columns:1.2fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 900px){
      .footer-grid{grid-template-columns:1fr}
    }
    .legend{
      border:1px solid #e6edf3;
      border-radius:10px;
      padding:10px;
      background:#fff;
    }
    .legend h4{margin:0 0 8px 0;font-size:12px;font-weight:900}
    .legend .item{
      display:flex;
      align-items:center;
      gap:8px;
      margin:6px 0;
      font-size:12px;
      font-weight:800;
      color:#2c3e50;
    }
    .swatch{
      width:18px;height:12px;border-radius:3px;border:1px solid rgba(0,0,0,.12);
    }

    .station-mini{
      display:grid;
      grid-template-columns:1fr 1fr 1fr;
      gap:8px;
      margin-top:8px;
    }
    @media (max-width: 900px){
      .station-mini{grid-template-columns:1fr}
    }
    .station-card{
      border:1px solid #e6edf3;
      border-radius:10px;
      padding:8px;
      background:#fbfdff;
    }
    .station-card .t{font-size:11px;color:#6b7a86;font-weight:900}
    .station-card .v{font-size:14px;font-weight:900;margin-top:3px}
    .station-actions{
      display:flex;
      gap:8px;
      margin-top:8px;
      flex-wrap:wrap;
    }

    /* ====== Map modal ====== */
    #mapModal{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:9999;
    }
    #mapCard{
      width:min(1100px, 96vw);
      height:min(700px, 88vh);
      background:#fff;
      border-radius:12px;
      overflow:hidden;
      box-shadow:var(--shadow);
      display:flex;
      flex-direction:column;
    }
    #mapTop{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      background:#fbfcfe;
      font-weight:900;
    }
    #mapBox{flex:1}

    /* ====== Loader ====== */
    #loader{
      display:none;
      font-size:12px;
      color:var(--muted);
      padding:8px 12px;
      border-top:1px solid var(--line);
    }

    /* ====== Print ====== */
    @media print{
      body{background:#fff}
      .side-panel{display:none!important}
      .app-shell{padding:0}
      .main-panel{box-shadow:none;border:none;border-radius:0}
      #mapModal{display:none!important}
      .no-print{display:none!important}
    }
  </style>
</head>

<body>

<div class="app-shell">

  <!-- ================= LEFT: GitHub Data panel ================= -->
  <aside class="side-panel">
    <div class="panel-topbar">
      <div> Î Î·Î³Î® Î”ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ : <span style="color:#ffeaa7">nireas</span></div>
      <button class="icon-btn" onclick="toggleCollapse('sideBody', this)">âˆ’</button>
    </div>

    <div id="sideBody">
      <div class="section">
        <div class="section-hdr">
          <div>ğŸ“¡ ÎœÎ•Î¤Î•Î©Î¡ÎŸÎ›ÎŸÎ“Î™ÎšÎŸÎ™ Î£Î¤Î‘Î˜ÎœÎŸÎ™</div>
          <button class="icon-btn" style="width:28px;height:24px" onclick="toggleCollapse('meteoBody', this)">âˆ’</button>
        </div>
        <div class="section-body" id="meteoBody">
          <div style="display:flex; gap:8px; align-items:center;">
            <select id="meteoStationSelect" style="flex:1">
              <option value="">Î•Ï€Î¹Î»Î¿Î³Î® ÏƒÏ„Î±Î¸Î¼Î¿Ï...</option>
            </select>
            <button class="mini-btn btn-map" onclick="openStationWeb()" title="Î†Î½Î¿Î¹Î³Î¼Î± ÏƒÎµ Î½Î­Î± ÎºÎ±ÏÏ„Î­Î»Î±">ğŸ”— Web</button>
          </div>

          <div style="display:flex; gap:8px; margin-top:8px;">
            <button class="mini-btn btn-load" style="flex:1; padding:8px;" onclick="fetchStationData()">â¬‡ï¸ Î›Î®ÏˆÎ· (API)</button>
            <button class="mini-btn btn-on" style="flex:1; padding:8px;" onclick="fetchLiveMeteo()">ğŸŒ Open-Meteo</button>
          </div>

          <div id="meteoStatus" style="font-size:10px;color:#6b7a86;margin-top:6px;font-style:italic;">Î‘Î½Î±Î¼Î¿Î½Î®â€¦</div>
        </div>
      </div>

      <div class="section">
        <div class="section-hdr">
          <div>ğŸ“ Î‘Î¡Î§Î•Î™Î‘ Î•Î¡Î“ÎŸÎ¥ (GEOJSON)</div>
          <button class="icon-btn" style="width:28px;height:24px" onclick="toggleCollapse('filesBody', this)">âˆ’</button>
        </div>

        <div class="section-body" id="filesBody" style="padding:0">
          <div id="loader">Î¦ÏŒÏÏ„Ï‰ÏƒÎ· Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î±Ï€ÏŒ GitHubâ€¦</div>
          <table>
            <thead>
              <tr>
                <th style="text-align:left;padding-left:10px;">ÎŒÎ½Î¿Î¼Î±</th>
                <th>Î¤ÏÏ€Î¿Ï‚</th>
                <th>Î•Î½Î­ÏÎ³ÎµÎ¹Î±</th>
              </tr>
            </thead>
            <tbody id="fileRows"></tbody>
          </table>
        </div>
      </div>

      <div class="hint">
        <b>Load</b> = Ï†Î¿ÏÏ„ÏÎ½ÎµÎ¹ Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏƒÏ„Î¿ ÎºÏÏÎ¹Î¿ ÎµÏÎ³Î±Î»ÎµÎ¯Î¿ (Ï€.Ï‡. Î»ÎµÎºÎ¬Î½Î·).<br/>
        <b>Map</b> = Ï€ÏÎ¿ÎµÏ€Î¹ÏƒÎºÏŒÏ€Î·ÏƒÎ· ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î· (zoom) <b>Ï‡Ï‰ÏÎ¯Ï‚</b> Î±Î»Î»Î±Î³Î® On/Off.<br/>
        <b>On/Off</b> = ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÎ¹/ÎºÏÏÎ²ÎµÎ¹ layer (Ï€Î¿Î»Î»Î±Ï€Î»Î­Ï‚ ÎµÏ€Î¹Î»Î¿Î³Î­Ï‚).<br/>
      </div>
    </div>
  </aside>

  <!-- ================= RIGHT: Peq Screening Tool ================= -->
  <main class="main-panel">
    <div class="tool-header">
      <h1>Î”Î•Î™ÎšÎ¤Î•Î£ Î‘Î ÎŸÎšÎ¡Î™Î£Î—Î£ Î¤ÎŸÎ Î™ÎšÎ©Î Î›Î•ÎšÎ‘ÎÎ©Î Î‘Î ÎŸÎ¡Î¡ÎŸÎ—Î£ â€” Peq Screening Tool</h1>
      <button class="print-btn no-print" onclick="window.print()">Î•ÎšÎ¤Î¥Î Î©Î£Î—</button>
    </div>

    <div class="tool-wrap">
      <div class="sel-basin">Î•Ï€Î¹Î»ÎµÎ³Î¼Î­Î½Î· Î»ÎµÎºÎ¬Î½Î·: <span id="selectedBasinName">â€”</span></div>

      <div class="grid-2">
        <div class="box" style="background:#fff3cd;border-color:#f1d27a">
          <h3>Î£Î•ÎÎ‘Î¡Î™ÎŸ Î’Î¡ÎŸÎ§Î—Î£</h3>
          <div class="row">
            <label>ÎˆÎ½Ï„Î±ÏƒÎ· i (mm/h):</label>
            <input type="number" id="rainI" value="0" step="0.1">
          </div>
          <div class="row">
            <label>Î”Î¹Î¬ÏÎºÎµÎ¹Î± D (min):</label>
            <input type="number" id="rainD" value="0" step="0.1">
          </div>
          <div style="font-size:11px;color:#6b7a86;text-align:right;">
            *Î‘Î½ D=0 â†’ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Tc (ÎµÎ»Î¬Ï‡Î¹ÏƒÏ„Î¿ 5 min)
          </div>
        </div>

        <div class="box" style="background:#97c9d1;border-color:#dfe7ee">
          <h3>ÎœÎ•Î¤Î•Î©Î¡ÎŸÎ›ÎŸÎ“Î™ÎšÎŸÎ£ Î£Î¤Î‘Î˜ÎœÎŸÎ£ (Monitor)</h3>
          <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;font-size:12px;">
            <div><b>Î£Ï„Î±Î¸Î¼ÏŒÏ‚:</b> <span id="stationName">â€”</span></div>
            <div><b>Timestamp:</b> <span id="stationTimestamp">â€”</span></div>
          </div>

          <div class="station-mini">
            <div class="station-card">
              <div class="t">Î’ÏÎ¿Ï‡Î® (mm/h)</div>
              <div class="v"><span id="stationRainRate">â€”</span></div>
            </div>
            <div class="station-card">
              <div class="t">Î”P (mm) <span id="stationTotalSrc" style="font-size:10px;color:#6b7a86"></span></div>
              <div class="v"><span id="stationDP">â€”</span></div>
            </div>
            <div class="station-card">
              <div class="t">R60 (mm)</div>
              <div class="v"><span id="stationR60">â€”</span></div>
            </div>
          </div>

          <div class="station-actions no-print">
            <button class="mini-btn btn-load" onclick="applyAutoI()">Auto</button>
            <button class="mini-btn btn-map" onclick="toggleLive()">Live</button>
            <button class="mini-btn btn-gray" onclick="clearStationSeries()">ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚</button>
          </div>
          <div id="stationMsg" style="font-size:10px;color:#6b7a86;margin-top:6px;font-style:italic;">â€”</div>
        </div>
      </div>

      <div class="panels-row">

        <div class="box" style="background:#eaf7ff;border-color:#bfe4ff">
          <h3>1. Î“Î•Î©ÎœÎ•Î¤Î¡Î™Î‘</h3>
          <div class="row"><label>Î•Î¼Î²Î±Î´ÏŒÎ½ A (mÂ²):</label><input type="number" id="area" value="0" step="1"></div>
          <div class="row"><label>ÎœÎ®ÎºÎ¿Ï‚ ÏÎ¿Î®Ï‚ L (m):</label><input type="number" id="length" value="0" step="1"></div>
          <div class="row"><label>Î¥ÏˆÎ¿Î¼. Î´Î¹Î±Ï†Î¿ÏÎ¬ H (m):</label><input type="number" id="height" value="0" step="0.1"></div>
          <div class="row"><label>Î£Ï…Î½Ï„ÎµÎ»ÎµÏƒÏ„Î®Ï‚ C:</label><input type="number" id="coef" value="0.40" step="0.01"></div>

          <div style="margin-top:10px">
            <canvas id="basinCanvas" width="340" height="180"></canvas>
          </div>
        </div>

        <div class="box" style="background:#eef9f1;border-color:#cfeee0">
          <h3>2. Î£Î¥Î›Î›ÎŸÎ“Î— (Î¦Î¡Î•Î‘Î¤Î™Î‘)</h3>
          <div class="row"><label>Î Î»Î®Î¸Î¿Ï‚:</label><input type="number" id="drains" value="0" step="1"></div>
          <div class="row"><label>Î™ÎºÎ±Î½ÏŒÏ„Î·Ï„Î±/Ï†ÏÎµÎ¬Ï„Î¹Î¿ (mÂ³/s):</label><input type="number" id="drainCap" value="0" step="0.01"></div>
          <div style="font-size:11px;color:#6b7a86;margin-top:6px">
            *Qcap_Î´Î¹ÎºÏ„ÏÎ¿Ï… = Ï€Î»Î®Î¸Î¿Ï‚ Ã— Î¹ÎºÎ±Î½ÏŒÏ„Î·Ï„Î±/Ï†ÏÎµÎ¬Ï„Î¹Î¿
          </div>
        </div>

        <div class="box" style="background:#f6f0ff;border-color:#e3d5ff">
          <h3>3. Î”Î™ÎŸÎ”Î•Î¥Î£Î— (Î¡Î•ÎœÎ‘)</h3>
          <div class="row"><label>Î Î»Î¬Ï„Î¿Ï‚ Ï€Ï…Î¸Î¼Î­Î½Î± b (m):</label><input type="number" id="strWidth" value="0" step="0.1"></div>
          <div class="row"><label>Î Î»Î¬Î³Î¹ÎµÏ‚ ÎºÎ»Î¯ÏƒÎµÎ¹Ï‚ z (H:V):</label><input type="number" id="strZ" value="0" step="0.1"></div>
          <div class="row"><label>Î’Î¬Î¸Î¿Ï‚ h (m):</label><input type="number" id="strDepth" value="0" step="0.1"></div>

          <div class="row">
            <label>n (Manning):</label>
            <select id="strType">
              <option value="0.030">0.030 (Î£ÎºÏ…ÏÏŒÎ´ÎµÎ¼Î±)</option>
              <option value="0.035">0.035 (ÎœÎµÎ¹ÎºÏ„ÏŒ/Î¤ÏÎ±Ï‡Ï)</option>
              <option value="0.045">0.045 (Î¦Ï…ÏƒÎ¹ÎºÎ® ÎºÎ¿Î¯Ï„Î·)</option>
              <option value="0.060">0.060 (Î Î¿Î»Ï Ï„ÏÎ±Ï‡Ï)</option>
            </select>
          </div>
          
          <div class="row"><label>ÎœÎ®ÎºÎ¿Ï‚ (m) (0=L):</label><input type="number" id="strLen" value="0" step="1"></div>
          <div class="row"><label>Î Ï„ÏÏƒÎ· (m) (0=H):</label><input type="number" id="strDrop" value="0" step="0.1"></div>
          
          <div class="row">
            <label>ÎÏˆÎ¿Ï‚ Î½ÎµÏÎ¿Ï y (m):</label>
            <input type="number" id="strY" value="" step="0.01" placeholder="Auto">
          </div>
          <div class="station-actions no-print" style="margin-top:6px">
            <button class="mini-btn btn-gray" onclick="resetStrY()">Auto y</button>
            <button class="mini-btn btn-map" onclick="openMapModal()">Î§Î¬ÏÏ„Î·Ï‚</button>
          </div>

          <div style="margin-top:10px">
            <canvas id="channelCanvas" width="340" height="180"></canvas>
          </div>
        </div>

      </div>

      <div class="summary-box">
        <div class="stat"><div class="k">ÎšÎ»Î¯ÏƒÎ· S</div><div class="v" id="res-slope">â€”</div></div>
        <div class="stat"><div class="k">Tc (Kirpich)</div><div class="v" id="res-tc">â€”</div></div>
        <div class="stat"><div class="k" style="color:#d35400">Qpeak</div><div class="v" id="res-qsel">â€”</div></div>
        <div class="stat"><div class="k">Qcap Î”Î¹ÎºÏ„ÏÎ¿Ï…</div><div class="v" id="res-drains">â€”</div></div>
        <div class="stat"><div class="k">Qcap Î¡Î­Î¼Î±Ï„Î¿Ï‚</div><div class="v" id="res-stream">â€”</div></div>
        <div class="stat"><div class="k">ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚</div><div class="v" id="res-adequacy">â€”</div></div>
      </div>

      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>i (mm/h)</th>
              <th>D (min)</th>
              <th>P (mm)</th>
              <th>Qpeak (mÂ³/s)</th>
              <th>V (mÂ³)</th>
              <th>Î•Ï€Î¹ÎºÎ¹Î½Î´Ï…Î½ÏŒÏ„Î·Ï„Î±</th>
              <th>Î”Î¯ÎºÏ„Ï…Î¿</th>
              <th>Î¡Î­Î¼Î±</th>
            </tr>
          </thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>

      <div class="footer-grid">
        <div class="legend">
          <h4>Î£Î·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚</h4>
          <div style="font-size:12px;color:#2c3e50;font-weight:800;line-height:1.35">
            â€¢ Qpeak: ÎœÎ­Î¸Î¿Î´Î¿Ï‚ Rational (0.278Â·CÂ·iÂ·A_kmÂ²)<br/>
            â€¢ Tc: Kirpich (min) â€¢ D: Î±Î½ D=0 â†’ D= max(5, Tc)<br/>
            â€¢ Î¡Î­Î¼Î±: Manning ÏƒÎµ Ï„ÏÎ±Ï€ÎµÎ¶Î¿ÎµÎ¹Î´Î® Î´Î¹Î±Ï„Î¿Î¼Î® (b, z, h)<br/>
          </div>
        </div>

        <div class="legend">
          <h4>Î¥Ï€ÏŒÎ¼Î½Î·Î¼Î± (Peq = PÂ·C)</h4>
          <div class="item"><span class="swatch" style="background:#eafaf1"></span> Î§Î±Î¼Î·Î»Î® (&lt;10 mm)</div>
          <div class="item"><span class="swatch" style="background:#fff7e6"></span> ÎœÎ­Ï„ÏÎ¹Î± (10â€“25 mm)</div>
          <div class="item"><span class="swatch" style="background:#ffe9d6"></span> Î¥ÏˆÎ·Î»Î® (25â€“40 mm)</div>
          <div class="item"><span class="swatch" style="background:#ffe0e0"></span> Î Î¿Î»Ï Î¥ÏˆÎ·Î»Î® (40â€“60 mm)</div>
          <div class="item"><span class="swatch" style="background:#ffd1d1"></span> Î‘ÎºÏÎ±Î¯Î± (â‰¥60 mm)</div>
        </div>
      </div>

    </div>
  </main>

</div>

<!-- ================= Map Modal ================= -->
<div id="mapModal" class="no-print">
  <div id="mapCard">
    <div id="mapTop">
      <div>ğŸ—ºï¸ Î ÏÎ¿Î²Î¿Î»Î® Î§Î¬ÏÏ„Î· (Ï€Î¿Î»Î»Î±Ï€Î»Î¬ layers)</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button class="mini-btn btn-gray" onclick="turnAllOff()">Off ÏŒÎ»Î±</button>
        <button class="mini-btn btn-gray" onclick="closeMapModal()">ÎšÎ»ÎµÎ¯ÏƒÎ¹Î¼Î¿</button>
      </div>
    </div>
    <div id="mapBox"></div>
  </div>
</div>

<script>
/* ===================== CONFIG ===================== */
const GH_USER   = 'petrsanidas-ui';
const GH_REPO   = 'nireas';
const GH_BRANCH = 'main';
const API_TREE  = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/git/trees/${GH_BRANCH}?recursive=1`;
const RAW_URL   = `https://raw.githubusercontent.com/${GH_USER}/${GH_REPO}/${GH_BRANCH}/`;

let DATA_GROUPS = { boundaries: [], streams: [], basins: [] }; // NOTE ORDER
let SELECTED_GEO = null;
let SELECTED_BASIN_KEY = null;

/* ===== Map state (multi-layer) ===== */
let map = null;
let baseLayer = null;
const GEO_CACHE = new Map();       // path -> geojson
const LAYER_CACHE = new Map();     // path -> leaflet layer
const VISIBLE = new Set();         // paths currently "On"
let PREVIEW_LAYER = null;          // temporary layer for Map button preview

/* ===== Station monitor ===== */
const STATION_SERIES_MAX = 12;
let stationSeries = [];
let stationLastKey = null;
let stationLiveOn = false;
let stationLiveTimer = null;
let lastStationPayload = null;

/* ===================== UI HELPERS ===================== */
function toggleCollapse(id, btn){
  const el = document.getElementById(id);
  if(!el) return;
  const isHidden = el.classList.toggle('collapsed');
  if(btn) btn.textContent = isHidden ? '+' : 'âˆ’';
}

function updateMeteoStatus(msg){
  const el = document.getElementById('meteoStatus');
  if(el) el.innerText = msg;
}
function setStationMsg(msg){
  const el = document.getElementById('stationMsg');
  if(el) el.innerText = msg;
}
function setTxt(id, txt){ const el=document.getElementById(id); if(el) el.textContent = txt; }

function isFiniteNumber(x){ return typeof x === 'number' && isFinite(x); }
function num(val){
  if(val==null) return 0;
  const n = (typeof val === 'number') ? val : parseFloat(String(val).replace(',','.'));
  return isFiniteNumber(n) ? n : 0;
}
function getVal(id){ return num(document.getElementById(id)?.value); }
function setVal(id, v){
  const el = document.getElementById(id);
  if(!el) return;
  el.value = (v==null) ? "" : v;
}

/* ===================== GITHUB LOAD ===================== */
async function init(){
  document.getElementById('loader').style.display = 'block';
  try{
    const resp = await fetch(API_TREE);
    const data = await resp.json();
    if(data.message) throw new Error(data.message);

    const files = data.tree || [];

    // IMPORTANT: paths based on your current repo layout (from previous versions)
    // data/boundaries, data/streams, data/basins
    DATA_GROUPS.boundaries = files.filter(f => f.path.includes('data/boundaries/') && f.path.endsWith('.geojson'));
    DATA_GROUPS.streams    = files.filter(f => f.path.includes('data/streams/')    && f.path.endsWith('.geojson'));
    DATA_GROUPS.basins     = files.filter(f => f.path.includes('data/basins/')     && f.path.endsWith('.geojson'));

    renderFileList();

    const stationFile =
      files.find(f => f.path === 'data/meteostations/weblinks/stations.txt') ||
      files.find(f => f.path.endsWith('/stations.txt') || f.path.endsWith('stations.txt')) ||
      files.find(f => f.path.endsWith('openmeteo.txt')) ||
      files.find(f => f.path.endsWith('ecmwf.txt'));

    if(stationFile) fetchStations(stationFile.path);
    else {
      updateMeteoStatus("Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î±ÏÏ‡ÎµÎ¯Î¿ ÏƒÏ„Î±Î¸Î¼ÏÎ½ (stations.txt / openmeteo.txt / ecmwf.txt)");
      // safe fallback: keep dropdown empty
    }

    bindInputs();
    runMasterCalculation();
  }catch(e){
    console.error(e);
    updateMeteoStatus("Î£Ï†Î¬Î»Î¼Î± GitHub: " + e.message);
  }finally{
    document.getElementById('loader').style.display = 'none';
  }
}

function renderFileList(){
  const tbody = document.getElementById('fileRows');
  tbody.innerHTML = '';

  const addCategory = (title, list, icon, color) => {
    const trHead = document.createElement('tr');
    trHead.className = 'cat-row';
    trHead.innerHTML = `<td colspan="3" style="color:${color}">${icon} ${title}</td>`;
    tbody.appendChild(trHead);

    list.forEach(f=>{
      const name = f.path.split('/').pop().replace('.geojson','');
      const tr = document.createElement('tr');

      const on = VISIBLE.has(f.path);
      tr.innerHTML = `
        <td style="text-align:left;padding-left:10px;">${name}</td>
        <td class="type-cell">GEOJSON</td>
        <td>
          <button class="mini-btn btn-load" onclick="loadToTool('${f.path}','${name}')">Load</button>
          <button class="mini-btn btn-map" onclick="previewOnMap('${f.path}','${name}')">Map</button>
          <button class="mini-btn ${on ? 'btn-on' : 'btn-off'}" id="btn-onoff-${cssSafe(f.path)}"
                  onclick="toggleLayer('${f.path}','${name}')">${on ? 'On' : 'Off'}</button>
        </td>
      `;
      tbody.appendChild(tr);
    });
  };

  // ORDER REQUESTED: boundaries -> streams -> basins
  addCategory("Î”Î¹Î¿Î¹ÎºÎ·Ï„Î¹ÎºÎ¬ ÎŒÏÎ¹Î±", DATA_GROUPS.boundaries, "ğŸ³ï¸", "#c0392b");
  addCategory("ğŸ’§ Î¥Î´ÏÎ¿Î³ÏÎ±Ï†Î¹ÎºÏŒ Î”Î¯ÎºÏ„Ï…Î¿", DATA_GROUPS.streams, "ğŸ’§", "#2980b9");
  addCategory("Î›ÎµÎºÎ¬Î½ÎµÏ‚ Î‘Ï€Î¿ÏÏÎ¿Î®Ï‚", DATA_GROUPS.basins, "ğŸ§º", "#2c3e50");
}

function cssSafe(s){
  return btoa(unescape(encodeURIComponent(s))).replace(/=+/g,'').replace(/[+/]/g,'_');
}

async function fetchGeoJSON(path){
  if(GEO_CACHE.has(path)) return GEO_CACHE.get(path);
  const resp = await fetch(RAW_URL + path);
  if(!resp.ok) throw new Error("Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ: " + path);
  const json = await resp.json();
  GEO_CACHE.set(path, json);
  return json;
}

/* ===================== LOAD / MAP / ON-OFF LOGIC ===================== */
async function loadToTool(path, name){
  updateMeteoStatus("Î¦ÏŒÏÏ„Ï‰ÏƒÎ·: " + name + "â€¦");
  try{
    const gj = await fetchGeoJSON(path);

    // Only basins are expected to populate the tool inputs
    const isBasin = path.includes('data/basins/');
    if(isBasin){
      SELECTED_GEO = gj;
      SELECTED_BASIN_KEY = path;
      document.getElementById('selectedBasinName').innerText = name;

      // reset only if you want a clean start
      // (keep user's values if not present)
      const p = getPropsMerged(gj);

      if(p.area!=null)   setVal('area', p.area);
      if(p.length!=null) setVal('length', p.length);
      if(p.height!=null) setVal('height', p.height);
      if(p.coef!=null)   setVal('coef', p.coef);

      if(p.drains!=null)   setVal('drains', p.drains);
      if(p.drainCap!=null) setVal('drainCap', p.drainCap);

      if(p.strWidth!=null) setVal('strWidth', p.strWidth);
      if(p.strZ!=null)     setVal('strZ', p.strZ);
      if(p.strDepth!=null) setVal('strDepth', p.strDepth);

      if(p.strLen!=null)   setVal('strLen', p.strLen);
      if(p.strDrop!=null)  setVal('strDrop', p.strDrop);

      if(p.strType!=null){
        // if exact match exists in select
        const sel = document.getElementById('strType');
        const val = String(p.strType);
        if([...sel.options].some(o=>o.value===val)) sel.value = val;
      }

      // IMPORTANT: do NOT auto-open map; do NOT change On/Off here
      updateMeteoStatus(`Î¦Î¿ÏÏ„ÏÎ¸Î·ÎºÎµ ÏƒÏ„Î¿ ÎµÏÎ³Î±Î»ÎµÎ¯Î¿: ${name}`);
      runMasterCalculation();
      drawBasinPlan();
    } else {
      // non-basin: just cache + message
      updateMeteoStatus(`Î¦Î¿ÏÏ„ÏÎ¸Î·ÎºÎµ (cache): ${name}`);
    }

  }catch(e){
    alert("Î£Ï†Î¬Î»Î¼Î±: " + e.message);
    updateMeteoStatus("Î£Ï†Î¬Î»Î¼Î± Ï†ÏŒÏÏ„Ï‰ÏƒÎ·Ï‚.");
  }
}

// Map preview: opens map, zooms to that layer, WITHOUT changing On/Off
async function previewOnMap(path, name){
  try{
    openMapModal();
    const gj = await fetchGeoJSON(path);

    // remove old preview
    if(PREVIEW_LAYER && map){
      map.removeLayer(PREVIEW_LAYER);
      PREVIEW_LAYER = null;
    }

    const cat = categoryFromPath(path);
    PREVIEW_LAYER = L.geoJSON(gj, {
      style: styleForCategory(cat, true)
    }).addTo(map);

    try{
      map.fitBounds(PREVIEW_LAYER.getBounds(), { padding:[20,20] });
    }catch(_){}

    // ensure visible layers remain visible (do not alter VISIBLE)
    syncVisibleLayersToMap();
  }catch(e){
    console.error(e);
    alert("Map error: " + e.message);
  }
}

// On/Off toggle: NO map open; NO zoom; just state + map update if map is open
async function toggleLayer(path, name){
  const btn = document.getElementById('btn-onoff-' + cssSafe(path));
  const turningOn = !VISIBLE.has(path);

  if(turningOn) VISIBLE.add(path);
  else VISIBLE.delete(path);

  if(btn){
    btn.textContent = turningOn ? 'On' : 'Off';
    btn.classList.toggle('btn-on', turningOn);
    btn.classList.toggle('btn-off', !turningOn);
  }

  // only update map if already open
  if(map) syncVisibleLayersToMap();
}

// Turn everything off
function turnAllOff(){
  VISIBLE.clear();
  // update buttons
  document.querySelectorAll('button[id^="btn-onoff-"]').forEach(b=>{
    b.textContent = 'Off';
    b.classList.remove('btn-on');
    b.classList.add('btn-off');
  });
  if(map) syncVisibleLayersToMap();
}

/* ===================== MAP MODAL ===================== */
function openMapModal(){
  const modal = document.getElementById('mapModal');
  modal.style.display = 'flex';
  if(!map){
    map = L.map('mapBox', { zoomControl:true });
    baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
      maxZoom:19, attribution:'&copy; OpenStreetMap'
    }).addTo(map);
    map.setView([38.02, 23.80], 12);
  }
  setTimeout(()=>map.invalidateSize(), 80);
  syncVisibleLayersToMap();
}

function closeMapModal(){
  const modal = document.getElementById('mapModal');
  modal.style.display = 'none';
  // remove preview layer when closing (keeps On/Off layers persistent)
  if(PREVIEW_LAYER && map){
    map.removeLayer(PREVIEW_LAYER);
    PREVIEW_LAYER = null;
  }
}

function categoryFromPath(path){
  if(path.includes('data/boundaries/')) return 'boundaries';
  if(path.includes('data/streams/')) return 'streams';
  return 'basins';
}

function styleForCategory(cat, preview=false){
  if(cat==='boundaries'){
    return { color: preview ? '#e74c3c' : '#c0392b', weight: preview ? 3 : 2, fill:false, dashArray: preview ? '6 4' : null };
  }
  if(cat==='streams'){
    return { color: preview ? '#2ecc71' : '#2980b9', weight: preview ? 4 : 3, fill:false, dashArray: preview ? '6 4' : null };
  }
  // basins
  return { color: preview ? '#27ae60' : '#d35400', weight: preview ? 2 : 2, fill:true, fillOpacity: preview ? 0.12 : 0.18, dashArray: preview ? '6 4' : null };
}

// Ensure map shows exactly all "On" layers (plus preview if present)
async function syncVisibleLayersToMap(){
  if(!map) return;

  // remove cached layers not in VISIBLE
  for(const [path, layer] of LAYER_CACHE.entries()){
    if(!VISIBLE.has(path) && map.hasLayer(layer)){
      map.removeLayer(layer);
    }
  }

  // add layers in VISIBLE
  for(const path of VISIBLE){
    let layer = LAYER_CACHE.get(path);
    if(!layer){
      const gj = await fetchGeoJSON(path);
      const cat = categoryFromPath(path);
      layer = L.geoJSON(gj, { style: styleForCategory(cat, false) });
      LAYER_CACHE.set(path, layer);
    }
    if(!map.hasLayer(layer)) layer.addTo(map);
  }
}

/* ===================== PROPERTIES EXTRACTION ===================== */
function getPropsMerged(gj){
  // merge props from FeatureCollection[0].properties or root.properties
  let p = {};
  try{
    if(gj && gj.features && gj.features[0] && gj.features[0].properties){
      p = {...gj.features[0].properties};
    } else if(gj && gj.properties){
      p = {...gj.properties};
    }
  }catch(_){}

  // normalize keys commonly used
  // area
  const area = pickNumber(p, ['A','a','area','Area','A_m2','area_m2','AREA_M2']);
  const length = pickNumber(p, ['L','l','length','Length','L_m','length_m','LEN_M']);
  const height = pickNumber(p, ['H','h','height','Height','H_m','height_m','DROP_M']);
  const coef = pickNumber(p, ['C','c','coef','Coef','runoff','runoff_coef']);

  const drains = pickNumber(p, ['drains','DrainCount','n_drains']);
  const drainCap = pickNumber(p, ['drainCap','DrainCap','drain_cap']);

  const strWidth = pickNumber(p, ['strWidth','b','width']);
  const strZ = pickNumber(p, ['strZ','z','side_slope']);
  const strDepth = pickNumber(p, ['strDepth','h_depth','depth']);

  const strLen = pickNumber(p, ['strLen','stream_len','channel_len']);
  const strDrop = pickNumber(p, ['strDrop','stream_drop','channel_drop']);
  const strType = pickNumber(p, ['strType','manning','n']);

  const out = {};
  if(area!=null) out.area = area;
  if(length!=null) out.length = length;
  if(height!=null) out.height = height;
  if(coef!=null) out.coef = coef;

  if(drains!=null) out.drains = drains;
  if(drainCap!=null) out.drainCap = drainCap;

  if(strWidth!=null) out.strWidth = strWidth;
  if(strZ!=null) out.strZ = strZ;
  if(strDepth!=null) out.strDepth = strDepth;

  if(strLen!=null) out.strLen = strLen;
  if(strDrop!=null) out.strDrop = strDrop;
  if(strType!=null) out.strType = strType;

  return out;
}

function pickNumber(obj, keys){
  for(const k of keys){
    if(obj && obj[k]!=null && String(obj[k]).trim()!==''){
      const n = parseFloat(String(obj[k]).replace(',','.'));
      if(isFiniteNumber(n)) return n;
    }
  }
  return null;
}

/* ===================== METEO: Stations list ===================== */
async function fetchStations(path){
  try{
    const resp = await fetch(RAW_URL + path);
    const text = await resp.text();
    const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);

    const sel = document.getElementById('meteoStationSelect');
    sel.innerHTML = '<option value="">Î•Ï€Î¹Î»Î¿Î³Î® ÏƒÏ„Î±Î¸Î¼Î¿Ï...</option>';

    const grpApi  = document.createElement('optgroup'); grpApi.label  = "API / JSON";
    const grpLink = document.createElement('optgroup'); grpLink.label = "Web Links";

    for(const line of lines){
      let name="", url=line;
      if(line.includes('|')){
        const parts = line.split('|');
        name = parts[0].trim();
        url = parts[1].trim();
      }else{
        name = url.replace(/^https?:\/\//,'').slice(0,50);
      }
      const opt = document.createElement('option');
      opt.value = url;
      opt.textContent = name || 'Station';

      // heuristic: if it looks like JSON/API endpoint or includes "exec"/"api"
      if(/(exec|api|json|\?)/i.test(url) && !/penteli\.meteo\.gr\/stations/i.test(url)) grpApi.appendChild(opt);
      else grpLink.appendChild(opt);
    }
    sel.appendChild(grpApi);
    sel.appendChild(grpLink);

    sel.addEventListener('change', ()=>{
      setTxt('stationName', sel.options[sel.selectedIndex]?.textContent || 'â€”');
      setTxt('stationTimestamp','â€”');
      setTxt('stationRainRate','â€”');
      setTxt('stationDP','â€”');
      setTxt('stationR60','â€”');
      setStationMsg('â€”');
    });

  }catch(e){
    console.error(e);
  }
}

function openStationWeb(){
  const url = document.getElementById('meteoStationSelect').value;
  if(url) window.open(url, '_blank');
}

/* ===================== METEO: Fetch (API button) ===================== */
async function fetchStationData(){
  const sel = document.getElementById('meteoStationSelect');
  const url = sel.value;
  if(!url) return;

  updateMeteoStatus("Î£ÏÎ½Î´ÎµÏƒÎ·â€¦");
  setTxt('stationName', sel.options[sel.selectedIndex]?.textContent || 'â€”');

  try{
    // 1) If URL is a JSON endpoint
    if(/json|api|exec|\?/i.test(url) && !/penteli\.meteo\.gr\/stations/i.test(url)){
      const r = await fetch(url).then(res=>res.json());
      lastStationPayload = r;

      const rr = extractRainRate(r);
      const ts = extractTimestamp(r) || new Date().toLocaleString('el-GR');
      const totals = extractTotals(r);

      updateStationMonitor(rr, ts, totals);
      updateMeteoStatus(`Î›Î®ÏˆÎ· OK: ${rr!=null ? rr.toFixed(1) : 'â€”'} mm/h`);
      setStationMsg("Î›Î®ÏˆÎ· Î±Ï€ÏŒ endpoint.");

      if(rr!=null){
        // keep a sample
        onNewStationSample(String(ts), ts, rr, sel.options[sel.selectedIndex]?.textContent || 'Station', totals);
      }
      runMasterCalculation();
      return;
    }

    // 2) If it's a meteo station page (CORS), try via r.jina.ai mirror
    if(/penteli\.meteo\.gr\/stations/i.test(url)){
      const mirror = url.startsWith('https://')
        ? ('https://r.jina.ai/' + url)
        : ('https://r.jina.ai/http://' + url.replace(/^http:\/\//,''));
      const txt = await fetch(mirror).then(res=>res.text());

      const parsed = parseMeteoPage(txt);
      if(parsed && parsed.rainRate!=null){
        const rr = parsed.rainRate;
        const ts = parsed.timestamp || new Date().toLocaleString('el-GR');
        updateStationMonitor(rr, ts, null);
        updateMeteoStatus(`Î›Î®ÏˆÎ· OK: ${rr.toFixed(1)} mm/h`);
        setStationMsg("Î›Î®ÏˆÎ· Î¼Î­ÏƒÏ‰ mirror (r.jina.ai).");
        onNewStationSample(String(ts), ts, rr, sel.options[sel.selectedIndex]?.textContent || 'Station', null);
        runMasterCalculation();
        return;
      }
      updateMeteoStatus("Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏƒÏ„Î· ÏƒÎµÎ»Î¯Î´Î± ÏƒÏ„Î±Î¸Î¼Î¿Ï.");
      setStationMsg("Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± parsing.");
      return;
    }

    // 3) Otherwise: just open web
    updateMeteoStatus("Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ API â€” Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¿ Web.");
    setStationMsg("ÎœÎ·-API ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Ï‚.");
  }catch(e){
    console.error(e);
    updateMeteoStatus("Î£Ï†Î¬Î»Î¼Î± Î»Î®ÏˆÎ·Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½.");
    setStationMsg("Î£Ï†Î¬Î»Î¼Î±: " + e.message);
  }
}

/* ===== Open-Meteo button (uses basin centroid if available) ===== */
async function fetchLiveMeteo(){
  updateMeteoStatus("Open-Meteoâ€¦");
  try{
    // default coords near Chalandri
    let lat = 38.02, lon = 23.80;

    // if selected basin exists, use first coordinate as quick proxy
    if(SELECTED_GEO && SELECTED_GEO.features && SELECTED_GEO.features[0]){
      const g = SELECTED_GEO.features[0].geometry;
      let c = null;
      if(g.type === 'Polygon') c = g.coordinates?.[0]?.[0];
      if(g.type === 'MultiPolygon') c = g.coordinates?.[0]?.[0]?.[0];
      if(g.type === 'LineString') c = g.coordinates?.[0];
      if(Array.isArray(c) && c.length>=2){
        lon = c[0]; lat = c[1];
      }
    }

    // include current precipitation_rate (mm/h) + hourly precipitation for R60 proxy
    const u = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&timezone=Europe%2FAthens&current=precipitation_rate&hourly=precipitation`;
    const r = await fetch(u).then(res=>res.json());

    const rr = r?.current?.precipitation_rate;
    const ts = r?.current?.time ? String(r.current.time) : new Date().toLocaleString('el-GR');

    updateStationMonitor(rr!=null ? rr : null, ts, null);
    updateMeteoStatus(`Live: ${rr!=null ? rr.toFixed(1) : 'â€”'} mm/h`);

    // keep sample if valid
    if(rr!=null){
      onNewStationSample(String(ts), ts, rr, 'Open-Meteo', null);
      setStationMsg("Live Î±Ï€ÏŒ Open-Meteo (precipitation_rate).");
      runMasterCalculation();
    }
  }catch(e){
    console.error(e);
    updateMeteoStatus("Error Open-Meteo");
    setStationMsg("Î£Ï†Î¬Î»Î¼Î± Open-Meteo: " + e.message);
  }
}

/* ===================== Station monitor logic ===================== */
function extractRainRate(obj){
  // common keys
  const keys = ['rainRate_mmh','rain_rate','rainRate','i','intensity','precipitation_rate','precip_rate'];
  for(const k of keys){
    if(obj && obj[k]!=null){
      const n = parseFloat(String(obj[k]).replace(',','.'));
      if(isFiniteNumber(n)) return n;
    }
  }
  // open-meteo shape
  const n2 = obj?.current?.precipitation_rate;
  if(isFiniteNumber(n2)) return n2;
  return null;
}
function extractTimestamp(obj){
  const keys = ['station_ts','timestamp','time','datetime','dateTime','lastUpdate','last_update'];
  for(const k of keys){
    if(obj && obj[k]) return String(obj[k]).trim();
  }
  // open-meteo
  if(obj?.current?.time) return String(obj.current.time);
  return null;
}
function extractTotals(obj){
  const t = {};
  t.today = pickNumber(obj, ['rainToday_mm','rain_today_mm','todayRain','today_rain']);
  t.storm = pickNumber(obj, ['stormTotal_mm','storm_total_mm','rainStorm','storm_total']);
  if(t.storm!=null){ t.total=t.storm; t.totalSrc='storm'; }
  else if(t.today!=null){ t.total=t.today; t.totalSrc='today'; }
  else { t.total=null; t.totalSrc=null; }
  return t;
}

function parseMeteoPage(text){
  // very lightweight heuristic (may vary by station page)
  // Try to find a mm/h value near "Rain Rate" or "mm/h"
  const rx = /([0-9]+(?:\.[0-9]+)?)\s*mm\/h/i;
  const m = text.match(rx);
  const rainRate = m ? parseFloat(m[1]) : null;

  // Try to find a timestamp-like pattern
  const tx = /(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2})/;
  const t = text.match(tx);
  const timestamp = t ? t[1] : null;

  return { rainRate, timestamp };
}

function updateStationMonitor(rainRate, tsText, totals){
  setTxt('stationTimestamp', tsText || 'â€”');
  setTxt('stationRainRate', (rainRate!=null && isFiniteNumber(rainRate)) ? rainRate.toFixed(1) : 'â€”');

  // dp/r60 derived from series
  if(totals && totals.total!=null){
    setTxt('stationTotalSrc', totals.totalSrc === 'storm' ? '(Storm)' : (totals.totalSrc === 'today' ? '(Î£Î®Î¼ÎµÏÎ±)' : ''));
  } else {
    setTxt('stationTotalSrc','');
  }
  updateStationReadouts();
}

function onNewStationSample(sampleKey, tsText, val, label, totals){
  if(!sampleKey) return;
  if(sampleKey === stationLastKey) return;
  stationLastKey = sampleKey;

  const prev = stationSeries.length ? stationSeries[stationSeries.length-1] : null;

  let dp = null;
  if(totals && totals.total!=null && prev && prev.total!=null && prev.totalSrc && prev.totalSrc === totals.totalSrc){
    dp = totals.total - prev.total;
    if(dp < 0) dp = totals.total;
  }

  const d = new Date();
  stationSeries.push({
    key: sampleKey,
    tsText: tsText || sampleKey,
    val,
    label,
    total: totals ? totals.total : null,
    totalSrc: totals ? totals.totalSrc : null,
    dp,
    dateMs: d.getTime()
  });

  if(stationSeries.length > STATION_SERIES_MAX) stationSeries = stationSeries.slice(-STATION_SERIES_MAX);
  updateStationReadouts();
}

function updateStationReadouts(){
  const latest = stationSeries.length ? stationSeries[stationSeries.length-1] : null;

  // dp = last dp if available
  const dp = latest?.dp;
  setTxt('stationDP', (dp!=null && isFiniteNumber(dp)) ? dp.toFixed(1) : 'â€”');

  // R60: sum dp over last 60 minutes if dp exists
  if(stationSeries.length && stationSeries.some(s=>s.dp!=null)){
    const now = stationSeries[stationSeries.length-1].dateMs;
    const cutoff = now - 60*60*1000;
    const sum = stationSeries.filter(s=>s.dateMs>=cutoff && s.dp!=null).reduce((a,b)=>a+b.dp,0);
    setTxt('stationR60', isFiniteNumber(sum) ? sum.toFixed(1) : 'â€”');
  } else {
    setTxt('stationR60', 'â€”');
  }
}

function applyAutoI(){
  // Use latest station rain rate if exists
  const latest = stationSeries.length ? stationSeries[stationSeries.length-1] : null;
  if(latest && latest.val!=null){
    setVal('rainI', latest.val.toFixed(1));
    setStationMsg("Auto: i ÎµÎ½Î·Î¼ÎµÏÏÎ¸Î·ÎºÎµ Î±Ï€ÏŒ ÏƒÏ„Î±Î¸Î¼ÏŒ.");
    runMasterCalculation();
  } else if(lastStationPayload){
    const rr = extractRainRate(lastStationPayload);
    if(rr!=null){
      setVal('rainI', rr.toFixed(1));
      setStationMsg("Auto: i ÎµÎ½Î·Î¼ÎµÏÏÎ¸Î·ÎºÎµ Î±Ï€ÏŒ payload.");
      runMasterCalculation();
    } else {
      setStationMsg("Auto: Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï„Î¹Î¼Î® Î²ÏÎ¿Ï‡Î®Ï‚.");
    }
  } else {
    setStationMsg("Auto: Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï„Î¹Î¼Î® Î²ÏÎ¿Ï‡Î®Ï‚.");
  }
}

function toggleLive(){
  stationLiveOn = !stationLiveOn;
  if(stationLiveOn){
    setStationMsg("Live: ON (Î±Î½Î¬ 90s)");
    stationLiveTimer = setInterval(()=> {
      // prefer API fetch if selected
      const url = document.getElementById('meteoStationSelect').value;
      if(url) fetchStationData();
      else fetchLiveMeteo();
    }, 90000);
  } else {
    setStationMsg("Live: OFF");
    if(stationLiveTimer) clearInterval(stationLiveTimer);
    stationLiveTimer = null;
  }
}

function clearStationSeries(){
  stationSeries = [];
  stationLastKey = null;
  setTxt('stationDP','â€”');
  setTxt('stationR60','â€”');
  setStationMsg("Series ÎºÎ±Î¸Î±ÏÎ¯ÏƒÏ„Î·ÎºÎµ.");
}

/* ===================== CALCULATIONS (ver14-style) ===================== */
function calculateTc(L, H){
  return (!L || !H) ? 10 : 0.0195 * Math.pow(L, 0.77) * Math.pow((H/L), -0.385);
}

function runMasterCalculation(){
  const area   = getVal('area');
  const length = getVal('length');
  const height = getVal('height');
  const coef   = getVal('coef');

  const rainI  = getVal('rainI');
  const rainD  = getVal('rainD');

  const drains   = getVal('drains');
  const drainCap = getVal('drainCap');

  const strWidth = getVal('strWidth');
  const strZ     = getVal('strZ');
  const strDepth = getVal('strDepth');
  const strDrop  = getVal('strDrop');
  const strLen   = getVal('strLen');
  const strType  = getVal('strType');
  const strYEl   = document.getElementById('strY');

  if(!(area>0)){
    // still draw empty
    setTxt('res-slope','â€”');
    setTxt('res-tc','â€”');
    setTxt('res-qsel','â€”');
    setTxt('res-drains','â€”');
    setTxt('res-stream','â€”');
    setTxt('res-adequacy','â€”');
    document.getElementById('tableBody').innerHTML='';
    drawChannel(0);
    drawBasinPlan();
    return;
  }

  const A_km2 = area / 1e6;
  const S = (length>0 && height>0) ? (height/length) : 0.01;

  const Tc = calculateTc(length, height);
  const Dused = (rainD > 0) ? rainD : Math.max(5.0, Tc);

  const Qsel = 0.278 * coef * rainI * A_km2;

  const CapNet = drains * drainCap;

  // Stream slope
  const sLen = (strLen>0) ? strLen : (length>0 ? length : 0);
  const sDrop = (strDrop>0) ? strDrop : (height>0 ? height : 0);
  const sSlope = (sLen>0) ? (sDrop/sLen) : 0;

  // Manning trapezoid capacity + normal depth by bisection
  let CapStr = 0;
  let yCalc = 0;

  const calcQ = (d) => {
    if(!(strWidth>0) || !(sSlope>0) || !(strType>0) || d<=0) return 0;
    const A = (strWidth + strZ*d) * d;
    const P = strWidth + 2*d*Math.sqrt(1 + Math.pow(strZ,2));
    return (1/strType) * Math.pow(A, 5/3) * Math.pow(P, -2/3) * Math.sqrt(sSlope);
  };

  if(strWidth>0 && strDepth>0 && sSlope>0){
    CapStr = calcQ(strDepth);

    if(Qsel>0){
      let low=0, high=(strDepth*2)||20;
      for(let i=0;i<22;i++){
        const mid=(low+high)/2;
        if(calcQ(mid) < Qsel) low=mid;
        else high=mid;
      }
      yCalc = (low+high)/2;
    }
  }

  // Manual y logic: if user types, treat as manual until resetStrY()
  if(strYEl){
    strYEl.addEventListener('input', ()=>{ strYEl.dataset.manual='true'; });
  }
  const isManual = strYEl?.dataset?.manual === 'true';
  const yMan = isManual ? num(strYEl.value) : 0;
  const finalY = isManual ? yMan : yCalc;

  // update y field if auto
  if(!isManual && document.activeElement !== strYEl){
    strYEl.value = (yCalc>0) ? yCalc.toFixed(2) : "";
  }

  // Stats
  setTxt('res-slope', (S*100).toFixed(1) + " %");

  // Tc display with min rule (like ver14 dual)
  const tcEl = document.getElementById('res-tc');
  if((!rainD || rainD<=0) && Tc < 5){
    tcEl.innerHTML = `<span style="color:#d35400;font-weight:900">5.0 min</span>
                      <div style="font-size:10px;color:#6b7a86">(calc: ${Tc.toFixed(2)})</div>`;
  }else{
    tcEl.textContent = Tc.toFixed(1) + " min";
  }

  setTxt('res-qsel', Qsel.toFixed(2) + " mÂ³/s");
  setTxt('res-drains', (CapNet>0 ? CapNet.toFixed(2) : "0.00") + " mÂ³/s");
  setTxt('res-stream', (CapStr>0 ? CapStr.toFixed(2) : "0.00") + " mÂ³/s");

  // adequacy label
  let adq = "<span style='color:#6b7a86'>â€”</span>";
  if(CapNet>0 && CapStr>0) adq = "<span class='status-ok'>Î”Î¹Ï€Î»ÏŒÏ‚ Î­Î»ÎµÎ³Ï‡Î¿Ï‚</span>";
  else if(CapNet>0) adq = "<span class='status-fail'>ÎœÏŒÎ½Î¿ ÏƒÏ…Î»Î»Î¿Î³Î®</span>";
  else if(CapStr>0) adq = "<span class='status-fail'>ÎœÏŒÎ½Î¿ Î´Î¹ÏŒÎ´ÎµÏ…ÏƒÎ·</span>";
  else adq = "<span class='status-warn'>Î§Ï‰ÏÎ¯Ï‚ Qcap</span>";
  document.getElementById('res-adequacy').innerHTML = adq;

  // Scenario table
  const tbody = document.getElementById('tableBody');
  tbody.innerHTML = "";

  const status = (Q, Cap) => {
    if(!(Cap>0)) return "<span class='status-fail' style='font-size:11px'>â€”</span>";
    if(Q <= Cap*0.85) return "<span class='status-ok'>OK</span>";
    if(Q <= Cap) return "<span class='status-warn'>ÎŸÏÎ¹Î±ÎºÏŒ</span>";
    return "<span class='status-fail'>Î¥Ï€Î­ÏÎ²Î±ÏƒÎ·</span>";
  };

  for(let i=5;i<=200;i+=5){
    const P = i*(Dused/60);
    const Q = 0.278*coef*i*A_km2;
    const V = area*(P/1000)*coef;
    const Peq = P*coef;

    let cls="risk-safe", txt="Î§Î±Î¼Î·Î»Î®";
    if(Peq>=60){cls="risk-extreme";txt="Î‘ÎºÏÎ±Î¯Î±";}
    else if(Peq>=40){cls="risk-red";txt="Î Î¿Î»Ï Î¥ÏˆÎ·Î»Î®";}
    else if(Peq>=25){cls="risk-orange";txt="Î¥ÏˆÎ·Î»Î®";}
    else if(Peq>=10){cls="risk-warn";txt="ÎœÎ­Ï„ÏÎ¹Î±";}

    const tr = document.createElement('tr');
    tr.className = cls;
    tr.innerHTML = `
      <td><b>${i}</b></td>
      <td>${Dused.toFixed(1)}</td>
      <td>${P.toFixed(1)}</td>
      <td>${Q.toFixed(2)}</td>
      <td>${Math.round(V).toLocaleString('el-GR')}</td>
      <td>${txt}<br><span style="font-size:11px;color:#6b7a86">Peq=${Peq.toFixed(1)}</span></td>
      <td>${status(Q, CapNet)}</td>
      <td>${status(Q, CapStr)}</td>
    `;
    tbody.appendChild(tr);
  }

  drawChannel(finalY);
  drawBasinPlan();
}

function resetStrY(){
  const el = document.getElementById('strY');
  if(!el) return;
  el.value = "";
  delete el.dataset.manual;
  runMasterCalculation();
}

/* ===================== VISUALIZERS ===================== */
function drawBasinPlan(){
  const canvas = document.getElementById('basinCanvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  // background
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,w,h);

  // If we have GeoJSON rings, draw them; else schematic
  const gj = SELECTED_GEO;
  const rings = gj ? geojsonToRings(gj) : [];
  const style = basinStyleFromInputs();

  if(rings && rings.length && drawGeoRings(ctx, rings, w, h, style)){
    // label
    ctx.fillStyle = "#2c3e50";
    ctx.font = "bold 10px Arial";
    ctx.fillText("Î ÎµÏÎ¯Î³ÏÎ±Î¼Î¼Î± (GeoJSON)", 8, 14);
    drawBasinLegend(ctx, style);
    return;
  }

  // schematic fallback based on A & L
  const A = getVal('area'), L = getVal('length');
  if(!(A>0) || !(L>0)){
    ctx.fillStyle="#9aa6b2";
    ctx.font="12px Arial";
    ctx.textAlign="center";
    ctx.fillText("ÎŸÏÎ¯ÏƒÏ„Îµ A & L Î® Ï†Î¿ÏÏ„ÏÏƒÏ„Îµ Î»ÎµÎºÎ¬Î½Î·", w/2, h/2);
    drawBasinLegend(ctx, style);
    return;
  }
  const W = A / L;
  const pad=14;
  const maxW=w-2*pad, maxH=h-2*pad;
  const scale = Math.min(maxW/(L||1), maxH/((W||1)));
  const Ls=L*scale, Ws=(W||1)*scale;
  const x=(w-Ls)/2, y=(h-Ws)/2;

  roundRect(ctx, x,y,Ls,Ws, Math.min(12, Ws/2, Ls/8));
  ctx.fillStyle = style.fill;
  ctx.fill();
  ctx.strokeStyle = style.stroke;
  ctx.lineWidth = style.lineWidth;
  ctx.stroke();

  ctx.fillStyle="#2c3e50";
  ctx.font="bold 10px Arial";
  ctx.textAlign="center";
  ctx.fillText(`Lâ‰ˆ${Math.round(L)} m`, w/2, h-6);

  ctx.save();
  ctx.translate(10, h/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign="center";
  ctx.fillText(`Wâ‰ˆ${Math.round(W)} m`, 0, 0);
  ctx.restore();

  drawBasinLegend(ctx, style);
}

function basinStyleFromInputs(){
  const Qpeak = 0.278 * getVal('coef') * getVal('rainI') * (getVal('area')/1e6);
  const CapNet = getVal('drains') * getVal('drainCap');
  const CapStr = estimateStreamCap();
  // simple coloring: fill by Peq class, stroke by capacity stress
  const Dused = (getVal('rainD')>0) ? getVal('rainD') : Math.max(5, calculateTc(getVal('length'), getVal('height')));
  const P = getVal('rainI')*(Dused/60);
  const Peq = P*getVal('coef');

  let fill="#eafaf1";
  if(Peq>=60) fill="#ffd1d1";
  else if(Peq>=40) fill="#ffe0e0";
  else if(Peq>=25) fill="#ffe9d6";
  else if(Peq>=10) fill="#fff7e6";

  let stroke="#2c3e50";
  let lw=2;
  const netBad = (CapNet>0 && Qpeak>CapNet);
  const strBad = (CapStr>0 && Qpeak>CapStr);
  if(netBad || strBad){ stroke="#c0392b"; lw=3; }
  else if((CapNet>0 && Qpeak>CapNet*0.85) || (CapStr>0 && Qpeak>CapStr*0.85)){ stroke="#d35400"; lw=3; }

  return { fill, stroke, lineWidth: lw };
}

function estimateStreamCap(){
  const strWidth = getVal('strWidth');
  const strZ = getVal('strZ');
  const strDepth = getVal('strDepth');
  const strDrop = getVal('strDrop');
  const strLen = getVal('strLen');
  const strType = getVal('strType');
  const length = getVal('length');
  const height = getVal('height');

  const sLen = (strLen>0)? strLen : length;
  const sDrop = (strDrop>0)? strDrop : height;
  const sSlope = (sLen>0)? (sDrop/sLen) : 0;
  if(!(strWidth>0) || !(strDepth>0) || !(sSlope>0) || !(strType>0)) return 0;
  const A = (strWidth + strZ*strDepth)*strDepth;
  const P = strWidth + 2*strDepth*Math.sqrt(1+strZ*strZ);
  return (1/strType) * Math.pow(A, 5/3) * Math.pow(P, -2/3) * Math.sqrt(sSlope);
}

function drawBasinLegend(ctx, style){
  const x=8, y=ctx.canvas.height-16;
  ctx.fillStyle="#2c3e50";
  ctx.font="bold 10px Arial";
  ctx.textAlign="left";
  ctx.fillText("Fill=Peq, Stroke=Qcap stress", x, y);
  // swatches
  ctx.fillStyle = style.fill;
  ctx.fillRect(ctx.canvas.width-58, ctx.canvas.height-22, 18, 12);
  ctx.strokeStyle = style.stroke;
  ctx.lineWidth = style.lineWidth;
  ctx.strokeRect(ctx.canvas.width-30, ctx.canvas.height-22, 18, 12);
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

function geojsonToRings(gj){
  const rings = [];
  try{
    const feat = gj.features ? gj.features[0] : gj;
    const g = feat.geometry || feat;
    if(!g) return rings;

    const pushPoly = (poly) => {
      // poly: [ [ [lon,lat], ... ] , holes... ]
      if(Array.isArray(poly) && poly.length){
        rings.push(poly[0]);
      }
    };

    if(g.type === 'Polygon') pushPoly(g.coordinates);
    if(g.type === 'MultiPolygon'){
      for(const poly of g.coordinates) pushPoly(poly);
    }
  }catch(_){}
  return rings;
}

function drawGeoRings(ctx, rings, w, h, style){
  try{
    // find bounds
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const r of rings){
      for(const [x,y] of r){
        if(x<minX) minX=x;
        if(y<minY) minY=y;
        if(x>maxX) maxX=x;
        if(y>maxY) maxY=y;
      }
    }
    if(!isFinite(minX) || !isFinite(maxX)) return false;

    const pad=14;
    const sx=(w-2*pad)/((maxX-minX)||1);
    const sy=(h-2*pad)/((maxY-minY)||1);
    const s=Math.min(sx,sy);

    const tx = (x)=> pad + (x-minX)*s;
    const ty = (y)=> h-pad - (y-minY)*s; // flip

    ctx.beginPath();
    for(const r of rings){
      for(let i=0;i<r.length;i++){
        const p = r[i];
        const X = tx(p[0]);
        const Y = ty(p[1]);
        if(i===0) ctx.moveTo(X,Y);
        else ctx.lineTo(X,Y);
      }
      ctx.closePath();
    }
    ctx.fillStyle = style.fill;
    ctx.fill();
    ctx.strokeStyle = style.stroke;
    ctx.lineWidth = style.lineWidth;
    ctx.stroke();
    return true;
  }catch(e){
    return false;
  }
}

function drawChannel(y_real){
  const canvas = document.getElementById('channelCanvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);

  const b = getVal('strWidth');
  const z = getVal('strZ');
  const H = getVal('strDepth');
  const y = y_real;

  if(b<=0 && H<=0){
    ctx.fillStyle="#9aa6b2";
    ctx.font="12px Arial";
    ctx.textAlign="center";
    ctx.fillText("ÎŸÏÎ¯ÏƒÏ„Îµ b & h", w/2, h/2);
    return;
  }

  const maxH = Math.max(H, y);
  const topW = b + 2*(z*maxH);
  const pad=20;
  const scale = Math.min((w-pad)/(topW||1),(h-pad)/(maxH||1));
  const cx=w/2, cy=h-16;

  const gx = (wd)=>(wd*scale)/2;
  const gy = (d)=> cy - (d*scale);

  const drawPoly = (tw, d, fill, stroke, dash=[])=>{
    ctx.beginPath();
    ctx.moveTo(cx-gx(tw), gy(d));
    ctx.lineTo(cx-gx(b), cy);
    ctx.lineTo(cx+gx(b), cy);
    ctx.lineTo(cx+gx(tw), gy(d));
    ctx.closePath();
    if(fill){ ctx.fillStyle=fill; ctx.fill(); }
    if(stroke){
      ctx.strokeStyle=stroke;
      ctx.setLineDash(dash);
      ctx.lineWidth=2;
      ctx.stroke();
      ctx.setLineDash([]);
    }
  };

  // banks outline
  if(H>0){
    drawPoly(b+2*z*H, H, null, "#5D4037");
  }
  // water
  if(y>0){
    const isOver = (H>0 && y>H);
    drawPoly(b+2*z*Math.min(y, H*1.5||y), Math.min(y, H*1.5||y),
      isOver ? "rgba(231,76,60,0.55)" : "rgba(52,152,219,0.55)",
      isOver ? "#c0392b" : "#2980b9",
      []
    );
    // waterline
    ctx.beginPath();
    ctx.moveTo(cx-gx(b+2*z*y), gy(y));
    ctx.lineTo(cx+gx(b+2*z*y), gy(y));
    ctx.strokeStyle="#2c3e50";
    ctx.lineWidth=1;
    ctx.stroke();

    ctx.fillStyle="#2c3e50";
    ctx.font="bold 10px Arial";
    ctx.textAlign="center";
    ctx.fillText(`y=${y.toFixed(2)}m`, cx, gy(y)-6);
  }

  ctx.fillStyle="#2c3e50";
  ctx.font="bold 10px Arial";
  ctx.textAlign="center";
  if(b>0) ctx.fillText(`b=${b}m`, cx, cy+12);
}

/* ===================== Inputs binding ===================== */
function bindInputs(){
  const ids = [
    'rainI','rainD','area','length','height','coef',
    'drains','drainCap',
    'strWidth','strZ','strDepth','strDrop','strLen','strType','strY'
  ];
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener('input', runMasterCalculation);
    el.addEventListener('change', runMasterCalculation);
  });
}


</script>

<script>
/* ===================== BOOT ===================== */
init();
</script>

</body>
</html>
